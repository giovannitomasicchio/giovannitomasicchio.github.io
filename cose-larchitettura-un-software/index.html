<!doctype html><html class=no-js lang=it><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Cos’è l’architettura di un software? - Giovanni Tomasicchio</title><script>(function(a,b){a[b]=a[b].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Cos’è l’architettura di un software?"><meta property="og:description" content="Prima di continuare a leggere questo post, provate a dare una risposta. Secondo vuoi cos’è l’architettura di un software?
Non si tratta di un discorso meramente teorico, finalizzato a trovare una definizione sterile. Al contrario, abbiamo bisogno di trovare una risposta perché da questa dipende la nostra capacità di valutare la bontà di una architettura. In altre parole abbiamo bisogno di sapere cos’è l’architettura di un software per avere un criterio che ci guidi nell’effettuare corrette scelte architetturali."><meta property="og:type" content="article"><meta property="og:url" content="https://giovannitomasicchio.github.io/cose-larchitettura-un-software/"><meta property="article:section" content="post"><meta property="article:published_time" content="2017-10-22T17:12:13+00:00"><meta property="article:modified_time" content="2017-10-22T17:12:13+00:00"><meta itemprop=name content="Cos’è l’architettura di un software?"><meta itemprop=description content="Prima di continuare a leggere questo post, provate a dare una risposta. Secondo vuoi cos’è l’architettura di un software?
Non si tratta di un discorso meramente teorico, finalizzato a trovare una definizione sterile. Al contrario, abbiamo bisogno di trovare una risposta perché da questa dipende la nostra capacità di valutare la bontà di una architettura. In altre parole abbiamo bisogno di sapere cos’è l’architettura di un software per avere un criterio che ci guidi nell’effettuare corrette scelte architetturali."><meta itemprop=datePublished content="2017-10-22T17:12:13+00:00"><meta itemprop=dateModified content="2017-10-22T17:12:13+00:00"><meta itemprop=wordCount content="1302"><meta itemprop=keywords content="architettura,design,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Cos’è l’architettura di un software?"><meta name=twitter:description content="Prima di continuare a leggere questo post, provate a dare una risposta. Secondo vuoi cos’è l’architettura di un software?
Non si tratta di un discorso meramente teorico, finalizzato a trovare una definizione sterile. Al contrario, abbiamo bisogno di trovare una risposta perché da questa dipende la nostra capacità di valutare la bontà di una architettura. In altre parole abbiamo bisogno di sapere cos’è l’architettura di un software per avere un criterio che ci guidi nell’effettuare corrette scelte architetturali."><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,regular,italic,600,600italic,700,700italic,800,800italic|Kaushan+Script:regular"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel="shortcut icon" href=/favicon.ico><script async src="https://www.googletagmanager.com/gtag/js?id=G-525H86QENV"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-525H86QENV',{anonymize_ip:!1})}</script></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Giovanni Tomasicchio" rel=home><div class="logo__item logo__text"><div class=logo__title>Giovanni Tomasicchio</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/articoli/><span class=menu__text>Articoli PHP</span></a></li><li class=menu__item><a class=menu__link href=/corsi/><span class=menu__text>Corsi</span></a></li><li class=menu__item><a class=menu__link href=/contatti/><span class=menu__text>Contatti</span></a></li><li class=menu__item><a class=menu__link href=/ricerca/><span class=menu__text>Ricerca</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Cos’è l’architettura di un software?</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-10-22T17:12:13Z>22 October 2017</time></div></div></header><figure class=post__thumbnail><img src=/image/blog/2017/10/architettura.jpeg alt="Cos’è l’architettura di un software?"></figure><div class="content post__content clearfix"><p>Prima di continuare a leggere questo post, provate a dare una risposta. Secondo vuoi cos’è l’architettura di un software?</p><p>Non si tratta di un discorso meramente teorico, finalizzato a trovare una definizione sterile. Al contrario, abbiamo bisogno di trovare una risposta perché da questa dipende la nostra capacità di <strong>valutare la bontà di una architettura</strong>. In altre parole abbiamo bisogno di sapere cos’è l’architettura di un software per avere un criterio che ci guidi nell’effettuare corrette <strong>scelte architetturali</strong>.</p><p>“Ma io non sono un architetto software, sono solo uno semplice sviluppatore!”. Mi sembra già di sentire qualcuno che, con questa motivazione, sta cercando di defilarsi dalla discussione. Questo “qualcuno”, magari inconsciamente, sta pensando che l’architettura del software sia qualcosa che riguarda i massimi sistemi, prerogativa di colleghi con i super poteri, che hanno smesso di sviluppare per dedicarsi allo sciamanesimo informatico. Riunitisi in stanze segrete, gli architetti cadono in trance ed elaborano progetti per la costruzione di <a href=https://it.wikipedia.org/wiki/La_cattedrale_e_il_bazaar>cattedrali</a> informatiche.</p><p>Se la pensate così, siete fuori strada. Vi anticipo che a mio avviso tutti gli sviluppatori, senza farci tanto caso, fanno continuamente scelte architetturali. Ma andiamo con ordine.</p><p>Se cercate sul web troverete diverse definizioni di architettura software, quasi tutte incentrate sulla scomposizione del sistema informatico in componenti e sulle reciproche interazioni. Piuttosto deludente, non trovate? Espresso così, il concetto di architettura risulta piuttosto <strong>statico</strong>, quasi a voler dire che, una volta definita, l’architettura non può cambiare. Inoltre non ci dà alcun indizio su come progettare una buona architettura. Spesso si utilizzano termini come “modulare”, “estensibile”, “scalabile”, per indicare delle caratteristiche di una buona architettura, che però non ci danno alcuna informazione sul vero metro di giudizio di un progetto: il <strong>costo</strong>.</p><p>A mio giudizio l’architettura di un software è semplicemente la somma delle scelte progettuali effettuate sugli aspetti non funzionali, ovvero non visibili all’utente finale. Mi riferisco in particolare alle scelte “importanti”, ovvero vincolanti per numerosi elementi del progetto e pertanto non semplici da cambiare, che indicano una precisa strada scelta tra le alternative disponibili. In questo senso l’architettura riguarda anche lo sviluppatore, anche se in contesti più circoscritti, quando si trova a dover scegliere tra implementazioni alternative di una particolare funzionalità.</p><p>A ben vedere non tutti gli elementi dell’architettura sono frutto di una valutazione e di una libera scelta. In alcuni casi infatti esiste una sola soluzione tecnologia che permetta di realizzare un particolare requisito. In questi casi non c’è alcuna scelta da fare. Ci sono inoltre elementi architetturali esplicitamente richiesti dal committente o, più raramente, anche dal PM. In questi casi è bene far mettere nero su bianco queste richieste, in modo che rientrino tra i requisiti software e rimangano distinti dalle scelte progettuali, di responsabilità del progettista.</p><h2 id=design-stamina-hypothesis>Design Stamina Hypothesis</h2><p>Ma quale criterio utilizzare per fare scelte architetturali? Come anticipato, a mio avviso a guidare le nostre scelte deve essere il costo. Ma in che termini? Ci viene in soccorso, come al solito, il buon <a href=https://martinfowler.com/>Martin Fowler</a> che ha formulato quella che lui chiama la <a href=https://martinfowler.com/bliki/DesignStaminaHypothesis.html>Design Stamina Hypothesis</a>. Secondo Fowler, nei contesti in cui la progettazione è assente (curva blu del grafico), si osserva una iniziale velocità nella realizzazione delle prime funzionalità che però, con l’aumentare del codice scritto, rallenta considerevolmente poiché diventa estremamente oneroso realizzare nuove funzionalità su una base di codice caotica. Al contrario, nei progetti che godono di una buona progettazione (curva rossa del grafico), si osserva una costante accelerazione della capacità di sviluppare sempre nuove funzionalità.</p><figure><img src=/image/blog/2017/10/designStaminaGraph.png><figcaption><h4>Martin Fowler - Design Stamina Hypothesis</h4></figcaption></figure><p>Questa costatazione empirica, facilmente riscontrabile nei progetti reali, può essere utilizzata come criterio di valutazione delle scelte architetturali. L’ipotesi di Fowler infatti ci suggerisce che se dobbiamo effettuare una scelta architetturale, tra le diverse alternative possibili, dobbiamo scegliere quella che maggiormente velocizza lo sviluppo delle nuove funzionalità, rendendole quindi più economiche. Certo, scegliere ad esempio tra un DB commerciale come Oracle ed un DB opensource come PostgreSQL comporta di per se delle ricadute economiche sul progetto, ma <strong>la velocità con cui un team di sviluppo realizza nuove funzionalità ha una valenza superiore, poiché al contempo economica e strategica</strong>. Un team di sviluppo messo nelle condizioni di realizzare velocemente nuove funzionalità permette, ad esempio, di anticipare un concorrente, completare un progetto nei tempi imposti dal committente, preparare una demo in tempo utile, più in generale ridurre il <a href=https://www.agilealliance.org/glossary/lead-time/>feature lead time</a>.</p><p>Assodato quindi che l’ipotesi di Fowler ha conseguenze tutt’altro che banali, è necessario approfondire altri due concetti. Infatti abbiamo detto che la bontà di una scelta architetturale si valuta in base a quanto questa agevolerà la <strong>realizzazione</strong> delle <strong>future</strong> funzionalità. Ma quali attività ricadono nel concetto di realizzazione? Inoltre, quanto è remoto il futuro da prevedere?</p><h2 id=costo-per-realizzare-una-nuova-funzionalità>Costo per realizzare una nuova funzionalità</h2><p>Per valutare l’impatto che avrà una scelta architetturale sulla realizzazione delle funzionalità del sistema, dobbiamo necessariamente individuare quali sono le attività che compongono l’intero processo di <strong>progettazione, sviluppo e rilascio</strong>. Spesso si tende a focalizzare tutta l’attenzione sulla fase di sviluppo software. Viene spontaneo infatti chiedersi come una scelta architetturale possa influenzare il codice sorgente. Niente di sbagliato, fintanto che la fase di progettazione e rilascio contribuiscono solo marginalmente al costo complessivo della realizzazione della funzionalità.</p><p>Ci sono però dei contesti, caratterizzati ad esempio da frequenti rilasci, da grandi team di sviluppo, dove la progettazione ed il rilascio hanno un peso preponderante sull’intero <em>effort</em> di realizzazione. In questi casi la valutazione degli impatti di una scelta architetturale non può limitarsi ad analizzare le ripercussioni sul solo codice sorgente.</p><h2 id=orizzonte-temporale>Orizzonte temporale</h2><p>Se è vero che la bontà di una scelta architetturale si valuta in base a quanto agevolerà la realizzazione delle future funzionalità, quanto lontano dobbiamo spingere la nostra previsione? Nell’ingegneria tradizionale, nonché nel modello di sviluppo del software <a href=https://it.wikipedia.org/wiki/Modello_a_cascata>a cascata</a>, la progettazione si deve concludere prima dell’avvio della attività di realizzazione: <em>plan your work, work your plan</em>. Questo approccio richiede quindi che tutte le scelte architetturali debbano essere effettuate prima dello sviluppo software. Di conseguenza l’orizzonte temporale da tener presente nella fase di progettazione è massimo, poiché deve contemplare le necessità dell’intera fase di sviluppo. Gli architetti software tendono persino ad andare oltre, e si sforzano di fare ipotesi sulle potenziali evoluzioni del sistema, tanto più improbabili quanto più collocabili in un futuro remoto. In pratica gli architetti si trasformano in profeti.</p><p>Questo <strong>approccio predittivo</strong> è stato fortemente messo in discussione negli anni, poiché basato implicitamente sulla stabilità dei requisiti software che si è dimostrata utopica. Le metodologie agili, come l’Extreme Programming, hanno invece puntato su un <strong>approccio adattativo</strong>, in grado di reagire alla variazione dei requisiti. Ne consegue che, nel contesto agile, l’orizzonte temporale da analizzare per valutare una scelta architetturale è più ristretto e le scelte architetturali non devono essere tutte prese prima di avviare lo sviluppo. Anzi, le stesse scelte architetturali possono essere oggetto di <a href=https://it.wikipedia.org/wiki/Refactoring>refactoring</a> durante lo sviluppo software.</p><p>Come regola di buon senso, ritengo che lo sforzo predittivo connesso ad una scelta architetturale debba essere proporzionato al costo di un successivo ripensamento. Tanto più sarà oneroso modificare una decisione progettuale, tanto più è necessario prevedere i suoi effetti a lungo termine.</p><h2 id=conclusioni>Conclusioni</h2><p>In questo post ho voluto condividere la mia visione dell’architettura di un software, certamente ispirata da grandi maestri. Secondo me l’architettura è un concetto tutt’altro che statico, composto da una miriade di scelte effettuate, lungo tutta la durata di un progetto, su aspetti invisibili all’utente finale ma che determinano il funzionamento del sistema. Obiettivo primario di queste scelte dovrebbe essere quello di velocizzare la realizzazione delle funzionalità di valore per l’utente. È necessario quindi analizzare le singole fasi di realizzazione di una funzionalità, per scoprire come velocizzarle, e prevedere, secondo un orizzonte temporale più o meno lungo, quali e quante funzionalità saranno impattate dalla particolare scelta architetturale.</p><p>Nel prossimo post proverò a fare qualche esempio di scelta architetturale pensata proprio per velocizzare la realizzazione del software.</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/architettura/ rel=tag>architettura</a></li><li class=tags__item><a class="tags__link btn" href=/tags/design/ rel=tag>design</a></li></ul></div></footer></article></main><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/ruolo-del-dominio-nello-sviluppo-applicazioni/ rel=prev><span class=pager__subtitle>«&#8201;Precedente</span><p class=pager__title>Il ruolo del dominio nello sviluppo di applicazioni</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=/organizzazione-dei-team-sviluppo/ rel=next><span class=pager__subtitle>Prossimo&#8201;»</span><p class=pager__title>Sull’organizzazione dei team di sviluppo</p></a></div></nav><section class=comments><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//giovannitomasicchio-it.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2021 Giovanni Tomasicchio.
<span class=footer__copyright-credits>Generato con <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> e il tema <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a>.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>