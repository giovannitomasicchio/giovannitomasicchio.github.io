<!doctype html><html class=no-js lang=it><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>PHP 5.1 - Note sull'aggiornamento - Giovanni Tomasicchio</title><script>(function(a,b){a[b]=a[b].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content="Le novità di PHP 5.1"><meta property="og:title" content="PHP 5.1 - Note sull'aggiornamento"><meta property="og:description" content="Le novità di PHP 5.1"><meta property="og:type" content="article"><meta property="og:url" content="https://giovannitomasicchio.github.io/articoli/php-51-note-sullaggiornamento/"><meta property="article:section" content="articoli"><meta property="article:published_time" content="2005-11-25T22:50:36+00:00"><meta property="article:modified_time" content="2005-11-25T22:50:36+00:00"><meta itemprop=name content="PHP 5.1 - Note sull'aggiornamento"><meta itemprop=description content="Le novità di PHP 5.1"><meta itemprop=datePublished content="2005-11-25T22:50:36+00:00"><meta itemprop=dateModified content="2005-11-25T22:50:36+00:00"><meta itemprop=wordCount content="2809"><meta itemprop=keywords content="database,MySQL,namespace,Oracle,sicurezza,mysqli,PDO,SPL,SQLite,"><meta name=twitter:card content="summary"><meta name=twitter:title content="PHP 5.1 - Note sull'aggiornamento"><meta name=twitter:description content="Le novità di PHP 5.1"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,regular,italic,600,600italic,700,700italic,800,800italic|Kaushan+Script:regular"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel="shortcut icon" href=/favicon.ico><script async src="https://www.googletagmanager.com/gtag/js?id=G-525H86QENV"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-525H86QENV',{anonymize_ip:!1})}</script></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Giovanni Tomasicchio" rel=home><div class="logo__item logo__text"><div class=logo__title>Giovanni Tomasicchio</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/articoli/><span class=menu__text>Articoli PHP</span></a></li><li class=menu__item><a class=menu__link href=/corsi/><span class=menu__text>Corsi</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>PHP 5.1 - Note sull'aggiornamento</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2005-11-25T22:50:36Z>25 November 2005</time></div></div></header><div class="content post__content clearfix"><p>L&rsquo;uscita di PHP 5.1 segna una piccola svolta nel percorso di PHP, non solo per le nuove funzionalità introdotte ma anche per alcune variazioni del comportamento del PHP Engine, il cuore di PHP, e per la riorganizzazione di diverse estensioni.</p><p>Per aiutare lo sviluppatore ad orientarsi nei cambiamenti introdotti e rendere il passaggio alla nuova release meno traumatico, sul sito ufficiale di PHP è stata pubblicata una <a href=http://www.php.net/README_UPGRADE_51.php>guida all&rsquo;aggiornamento</a> di cui riporto la traduzione.</p><ol><li><a href=#cirh>Variazioni nella gestione dei riferimenti</a></li><li><a href=#overview>Panoramica</a></li><li><a href=#cirh2>Codice che funzionava sotto PHP 4.3, ma che ora fallisce</a></li><li><a href=#cirh3>Codice che era valido sotto PHP 4.3, ma che ora produce errori</a></li><li><a href=#cirh4>Codice che fallisce sotto PHP 4.3, ma ora funziona</a></li><li><a href=#cirh5>Codice che &lsquo;avrebbe dovuto funzionare&rsquo; sotto PHP 5.0</a></li><li><a href=#cirh6>Avvisi che vanno e vengono</a></li><li><a href=#reading>Lettura []</a></li><li><a href=#is_a>instanceof, is_a(), is_subclass_of(), catch</a></li><li><a href=#int>Valori interi nei parametri di funzione</a></li><li><a href=#abstract>Metodi privati astratti</a></li><li><a href=#ami>Modificatori di accesso nelle interfacce</a></li><li><a href=#cir>Cambiamenti nelle regole di ereditarietà</a></li><li><a href=#cc>Costanti di classe</a></li><li><a href=#extensions>Estensioni</a></li><li><a href=#extensions1>Estensioni che sono scomparse dal nucleo di PHP</a></li><li><a href=#extensions2>Costanti di classe nelle nuove estensioni di PHP 5.1</a></li><li><a href=#date>Supporto per date e tempo</a></li><li><a href=#db>Variazioni nel supporto ai database</a></li><li><a href=#db1>Panoramica su PDO</a></li><li><a href=#db2>Cambiamenti nel supporto a MySQL</a></li><li><a href=#db3>Variazioni nel supporto a SQLite</a></li><li><a href=#misc>Ulteriori informazioni sulla migrazione</a></li><li><a href=#estrict>Controllo degli errori E_STRICT</a></li></ol><h2 id=a-idcirh-namecirh1-variazioni-nella-gestione-dei-riferimentia>1. Variazioni nella gestione dei riferimenti</h2><h3 id=a-idoverview-nameoverview1a-panoramicaa>1a. Panoramica</h3><p>Dal punto di vista del programmatore PHP, il cambiamento che più probabilmente influenzerà il vecchio codice riguarda il modo in cui vengono gestiti i riferimenti in tutte le versioni successive alla 4.4.0.
Fino alla versione 4.3 inclusa, era possibile inviare, assegnare o restituire variabili tramite riferimento, quando invece dovevano essere restituite per valore, come nel caso di una costante, di un valore temporaneo (ad es. il risultato di un&rsquo;espressione), o del risultato di una funzione che avrebbe dovuto essere restituito per valore, come nel seguente script:</p><pre><code>&lt;pre class=&quot;brush: php&quot;&gt;
&lt;?php 
$foo = &quot;123&quot;;

function return_value() {
   global $foo;
   return $foo;
}

$bar = &amp;return_value();
?&gt;
</code></pre><p>Sebbene questo codice normalmente fornisce i risultati attesi sotto PHP 4.3, in generale il risultato è indefinito. Il Motore Zend non potrebbe agire correttamente su questi valori trattandoli come riferimenti. Questo baco poteva ed ha effettivamente condotto a vari problemi di corruzione della memoria difficili da riprodurre, soprattutto nel caso di grossi script.
In PHP 4.4.0, 5.0.4 ed in tutte le versioni successive, il Motore è stato corretto in modo da riconoscere quando l&rsquo;operatore di riferimento viene usato su di un valore che non dovrebbe essere referenziato. In questi casi viene utilizzato il valore effettivo, ed è visualizzato un messaggio di avvertimento. Il messaggio prende la forma di un E_NOTICE in PHP 4.4.0 e successivi, e di un E_STRICT in PHP 5.0.4 e successivi.
Il codice che potenzialmente poteva produrre corruzione di memoria non può più farlo. Comunque qualche vecchio script potrebbe di conseguenza funzionare in modo diverso da quello atteso.</p><h3 id=a-idcirh2-namecirh21b-codice-che-funzionava-sotto-php-43-ma-che-ora-falliscea>1b. Codice che funzionava sotto PHP 4.3, ma che ora fallisce</h3><pre><code>&lt;pre class=&quot;brush: php&quot;&gt;
&lt;?php 
function func(&amp;$arraykey) {
   return $arraykey; // function returns by value!
}

$array = array('a', 'b', 'c');
foreach (array_keys($array) as $key) {
   $y = &amp;func($array[$key]);
   $z[] =&amp; $y;
}

var_dump($z);
?&gt;
</code></pre><p>Facendo girare lo script precedente sotto qualsiasi versione di PHP che precede la correzione della gestione dei riferimenti, si produrrebbe questo output:</p><pre><code>
array(3) {
  [0]=&gt;
  &amp;string(1) &quot;a&quot;
  [1]=&gt;
  &amp;string(1) &quot;b&quot;
  [2]=&gt;
  &amp;string(1) &quot;c&quot;
}
</code></pre><p>Con la correzione della gestione dei riferimenti, lo stesso codice produrrebbe questo risultato:</p><pre><code>
array(3) {
  [0]=&gt;
  &amp;string(1) &quot;c&quot;
  [1]=&gt;
  &amp;string(1) &quot;c&quot;
  [2]=&gt;
  &amp;string(1) &quot;c&quot;
}
</code></pre><p>Questo accade perché, seguendo i cambiamenti, func() assegna per valore. Il valore di $y è ri-assegnato ed il collegamento per riferimento è preservato da $z. Prima della correzione, il valore era assegnato per riferimento, portando $y ad essere ri-collegato ad ogni assegnazione. Il tentativo di legare ad un valore temporaneo attraverso il riferimento era la causa della corruzione della memoria.
Quel codice può essere fatto funzionare in modo identico sia nelle versione di PHP precedenti che in quelle successive alla correzione della gestione dei riferimenti. La firma di func() può essere modificata in modo da restituire tramite riferimento, oppure l&rsquo;assegnazione per riferimento può essere rimossa dal risultato di func().</p><pre><code>&lt;pre class=&quot;brush: php&quot;&gt;
&lt;?php 
function func() {
   return 'function return';
}

$x = 'original value';
$y =&amp; $x;
$y = &amp;func();
echo $x;
?&gt;
</code></pre><p>In PHP 4.3 $x sarebbe &lsquo;original value&rsquo;, mentre dopo le variazioni sarebbe &lsquo;function return&rsquo;, ricordate che dove la funzione non restituisce il valore tramite riferimento, l&rsquo;assegnazione del riferimento è convertita in una regolare assegnazione. Anche questa volta è possibile allineare il comportamento dello script, forzando func() a restituire il risultato tramite riferimento oppure eliminando l&rsquo;assegnazione tramite riferimento.</p><h3 id=a-idcirh3-namecirh31c-codice-che-era-valido-sotto-php-43-ma-che-ora-produce-erroria>1c. Codice che era valido sotto PHP 4.3, ma che ora produce errori</h3><pre><code>&lt;pre class=&quot;brush: php&quot;&gt;
&lt;?php 
class Foo {

   function getThis() {
       return $this;
   }

   function destroyThis() {
       $bar =&amp; $this-&gt;getThis();
   }
}

$bar = new Foo();
$bar-&gt;destroyThis();
var_dump($bar);
?&gt;
</code></pre><p>In PHP 5.0.3, $bar vale NULL invece di essere un oggetto. Ciò succede perché getThis() restituisce un risultato tramite valore, ma il valore nell&rsquo;esempio è assegnato tramite riferimento. Sebbene adesso funzioni nel modo atteso, questo è in realtà un codice invalido che lancia un E_NOTICE sotto PHP 4.4 o un E_STRICT sotto PHP 5.0.4 e successivi.</p><h3 id=a-idcirh4-namecirh41d-codice-che-fallisce-sotto-php-43-ma-ora-funzionaa>1d. Codice che fallisce sotto PHP 4.3, ma ora funziona</h3><pre><code>&lt;pre class=&quot;brush: php&quot;&gt;
&lt;?php 
function &amp;f() {
   $x = &quot;foo&quot;;
   var_dump($x);
   print &quot;$x\n&quot;;
   return($a);
}

for ($i = 0; $i &lt; 3; $i++) {
   $h = &amp;f();
}
?&gt;
</code></pre><p>In PHP 4.3 la terza chiamata a var_dump produce NULL, ciò è dovuto alla corruzione della memoria causata dalla restituzione di un valore non inizializzato tramite riferimento. Questo è un codice valido in PHP 5.0.4 e successivi, ma produce errori nelle precedenti versioni di PHP.</p><pre><code>&lt;pre class=&quot;brush: php&quot;&gt;
&lt;?php 
$arr = array('a1' =&gt; array('alfa' =&gt; 'ok')); 
$arr =&amp; $arr['a1']; 
echo '-'.$arr['alfa'].&quot;-\n&quot;; 
?&gt;
</code></pre><p>Prima di PHP 5.0.5 non era possibile assegnare un array tramite riferimento in questo modo. Ora è possibile.</p><h3 id=a-idcirh5-namecirh51e-codice-che-avrebbe-dovuto-funzionare-sotto-php-50a>1e. Codice che &lsquo;avrebbe dovuto funzionare&rsquo; sotto PHP 5.0</h3><p>Ci sono un paio di bachi riportati sotto PHP 5.0 prima della correzione della gestione dei riferimenti che adesso &lsquo;funzionano&rsquo;. Comunque, in entrambi i casi vengono lanciati degli errori da PHP 5.1, poiché il codice non è comunque corretto. Restituire valori tramite riferimento utilizzando self:: in generale ora funziona ma produce un avviso E_STRICT, e sebbene il risultato può variare effettuando assegnazioni per riferimento ad un oggetto sovraccaricato, otterrete ancora un E_ERROR quando lo provate, anche quando l&rsquo;assegnazione stessa sembra funzionare.</p><h3 id=a-idcirh6-namecirh61f-avvisi-che-vanno-e-vengonoa>1f. Avvisi che vanno e vengono</h3><pre><code>&lt;pre class=&quot;brush: php&quot;&gt;
&lt;?php 
function &amp; foo() {
   $var = 'ok';
   return $var;
}

function &amp; bar() {
   return foo();
}

$a =&amp; bar();
echo &quot;$a\n&quot;;
?&gt;
</code></pre><p>Chiamate annidate a funzioni che restituiscono valori tramite riferimento sono valide sotto PHP 4.3 e PHP 5.1 ma lanciano un ingiustificato E_NOTICE o E_STRICT con le altre versioni.</p><h2 id=a-idreading-namereading2-lettura-a>2. Lettura []</h2><pre><code>&lt;pre class=&quot;brush: php&quot;&gt;
&lt;?php 
class XmlTest {

   function test_ref(&amp;$test) {
       $test = &quot;ok&quot;;
   }

   function test($test) { }

   function run() {
       $ar = array();
       $this-&gt;test_ref($ar[]);
       var_dump($ar);
       $this-&gt;test($ar[]);
   }
}

$o = new XmlTest();
$o-&gt;run();
?&gt; 
</code></pre><p>Questo esempio avrebbe dovuto lanciare sempre un E_ERROR visto che [] non può essere utilizzato per leggere in PHP. Questo è un codice invalido da PHP 4.4.2 e PHP 5.0.5 in poi.</p><h2 id=a-idis_a-nameis_a3-instanceof-is_a-is_subclass_of-catch-a>3. instanceof, is_a(), is_subclass_of(), catch</h2><p>In PHP 5.0, is_a() è stato deprecato e rimpiazzato dall&rsquo;operatore &lsquo;instanceof&rsquo;. C&rsquo;erano alcune questioni aperte dall&rsquo;iniziale implementazione di &lsquo;instanceof&rsquo;, che dipendevano dalla ricerca delle classi mancanti da parte di __autoload(). Se la classe non fosse stata presente, &lsquo;instanceof&rsquo; avrebbe lanciato un E_ERROR fatale dovuto al tentativo fallito di __autoload() nel trovare tale classe. Lo stesso accadeva per l&rsquo;operatore &lsquo;catch&rsquo; e la funzione is_subclass_of(), per lo stesso motivo.
Nessuna di queste funzioni o operatori chiama __autoload() in PHP 5.1, e l&rsquo;utilizzo di class_exists() come espediente nel codice scritto per PHP 5.0, benché non crei alcun problema, non è più necessario.</p><h2 id=a-idint-nameint4-valori-interi-nei-parametri-di-funzionea>4. Valori interi nei parametri di funzione</h2><p>Con l&rsquo;avvento di PHP 5.0, è stato introdotto nelle API un nuovo sistema di analisi dei parametri che viene utilizzato da un gran numero di funzioni PHP. In tutte le versioni tra la 5.0 e la 5.1, il trattamento dei valori interi era molto rigoroso, tanto che avrebbe rigettato valori numerici non correttamente formattati quando una funzione PHP si aspettava un intero. Queste verifiche ora sono state rese meno rigorose in modo da supportare stringhe numeriche non ben-formattate come " 123" e &ldquo;123 &ldquo;, e non produrranno più il fallimento come succedeva con PHP 5.0. Comunque, per promuovere la sicurezza del codice e la validazione dell&rsquo;input, le funzioni PHP produrranno un E_NOTICE quando tali stringhe sono passate come interi.</p><h2 id=a-idabstract-nameabstract5-metodi-privati-astrattia>5. Metodi privati astratti</h2><p>I metodi privati astratti erano supportati tra PHP 5.0.0 e PHP 5.0.4, ma sono stati successivamente aboliti a causa della mutua esclusività dei comportamenti &lsquo;privato&rsquo; e &lsquo;astratto&rsquo;.</p><h2 id=a-idami-nameami6-modificatori-di-accesso-nelle-interfaccea>6. Modificatori di accesso nelle interfacce</h2><p>Sotto PHP 5.0, le dichiarazioni delle funzioni nelle interfacce erano trattate nello stesso modo delle dichiarazioni di funzioni nelle classi. Ciò fino all&rsquo;Ottobre 2004, quando nella dichiarazione delle funzioni di interfaccia è stato autorizzato solo il modificatore di accesso &lsquo;public&rsquo;. Dall&rsquo;Aprile 2005 , prima dell&rsquo;uscita di PH 5.0b1 , anche il modificatore &lsquo;static&rsquo; è stato autorizzato. Comunque, i modificatori &lsquo;protected&rsquo; e &lsquo;private&rsquo; non lanceranno un E_ERROR, come farà invece il modificatore &lsquo;abstract&rsquo;. Si noti che questa variazione non dovrebbe interessare il vostro codice esistente, poiché nessuno di questi modificatori ha senso nel contesto delle interfacce.</p><h2 id=a-idcir-namecir7-cambiamenti-nelle-regole-di-ereditarietàa>7. Cambiamenti nelle regole di ereditarietà</h2><p>Sotto PHP 5.0 era possibile avere una dichiarazione di funzione in una classe derivata che non combaciava con la dichiarazione della stessa funzione nella classe base, ad es.</p><pre><code>&lt;pre class=&quot;brush: php&quot;&gt;
class Base {
   function &amp;return_by_ref() {
       $r = 1;
       return $r;
   }
}

class Derived extends Base {
   function return_by_ref() {
       return 1;
   }
}
</code></pre><p>Questo codice causerà la generazione di un errore E_STRICT in PHP 5.1.</p><h2 id=a-idcc-namecc8-costanti-di-classea>8. Costanti di classe</h2><p>Sotto PHP 5.0 il seguente codice era valido:</p><pre><code>&lt;pre class=&quot;brush: php&quot;&gt;
&lt;?php 
class test {
   const foobar = 'foo';
   const foobar = 'bar';
}
?&gt; 
</code></pre><p>Sotto PHP 5.1, la ri-definizione di una costante di classe lancerà un fatale E_ERROR.</p><h2 id=a-idextensions-nameextensions9-estensionia>9. Estensioni</h2><h3 id=a-idextensions1-nameextensions19a-estensioni-che-sono-scomparse-dal-nucleo-di-phpa>9a. Estensioni che sono scomparse dal nucleo di PHP</h3><p>Una delle prime cose che probabilmente noterete scaricando PHP 5.1 è che molte delle estensioni sono scomparse. Le estensioni ancora attivamente sviluppate sono disponibili in PECL (PHP Extension Community Library), all&rsquo;indirizzo <a href=http://pecl.php.net/>http://pecl.php.net</a>. I binari per Windows vengono regolarmente compilati, ed è possibile procurarsi i binari delle estensioni PECL compilati per PHP 5.1 da <a href=http://pecl4win.php.net/list.php/5_1>http://pecl4win.php.net/list.php/5_1</a>.</p><pre><code>
Estensioni          Alternativa/stato
=========           ========================
ext/cpdf            pecl/pdflib
ext/dbx             pecl/dbx
ext/dio             pecl/dio
ext/fam             not actively maintained
ext/ingres_ii       pecl/ingres
ext/ircg            not actively maintained
ext/mcve            pecl/mcve
ext/mnogosearch     not actively maintained
ext/oracle          ext/oci8 or ext/pdo_oci
ext/ovrimos         not actively maintained
ext/pfpro           not actively maintained - alternatives at
                   http://pecl.php.net/packages.php?catpid=18&amp;catname=Payment
ext/w32api          pecl/ffi
ext/yp              not actively maintained
sapi/activescript   http://pecl4win.php.net/ext.php/php5activescript.dll (PECL package)
                   or pecl/activescript (CVS)
</code></pre><p>I moduli in PECL che non sono attivamente sviluppati (non sono stati supportati per un certo tempo, non c&rsquo;è attualmente un attivo lavoro di manutenzione su di esse, e non hanno nessuna versione di package PECL), sono ancora disponibili in CVS su <a href=http://cvs.php.net/pecl/>http://cvs.php.net/pecl/</a>. Comunque i moduli non rilasciati da PHP sono per loro natura non supportati, ed i risultati potranno essere diversi quando cercate di installarli o usarli.</p><h3 id=a-idextensions2-nameextensions29b-costanti-di-classe-nelle-nuove-estensioni-di-php-51a>9b. Costanti di classe nelle nuove estensioni di PHP 5.1</h3><p>Le API del Motore Zend permettono agli sviluppatori di dichiarare costanti nelle classi in estensioni orientate agli oggetti. Nuove estensioni scritte per PHP 5.1, incluse SPL, PDO, ext/XMLReader ed ext/date, hanno le loro costanti nel formato</p><p>PDO::CLASS_CONSTANT</p><p>piuttosto che nel formato C</p><p>PDO_CLASS_CONSTANT</p><p>in modo da minimizzare la confusione del namespace globale in PHP.</p><p>Si noti che la nuova classe Date esiste al momento solamente per permettere all&rsquo;estensione &lsquo;core&rsquo; delle date di aderire alla convenzione qui sopra, sebbene siano state pianificate per il futuro ulteriori funzionalità per la classe.</p><h2 id=a-iddate-namedate10-supporto-per-date-e-tempo-a>10. Supporto per date e tempo</h2><p>Il supporto a date/time è stato completamente riscritto in PHP 5.1, che non usa più le impostazioni del sistema per conoscere il fuso orario nelle operazioni. Verranno invece impiegati, nel seguente ordine:</p><ul><li>il fuso orario settato dalla funzione date_default_timezone_set() (se impiegata)</li><li>la variabile d&rsquo;ambiente TZ (se non è vuota)</li><li>l&rsquo;opzione date.timezone nel php.ini (se impostata)</li><li>supposizione &ldquo;magica&rdquo; (se il sistema operativo la supporta)</li><li>se nessuna delle opzioni precedenti ha successo, UTC</li></ul><p>Per assicurare accuratezza (ed evitare avvisi E_STRICT), è necessario definire il proprio fuso orario nel php.ini usando il seguente formato:
date.timezone = Europe/London
I fusi orari supportati sono elencati, in questo formato nel manuale PHP su <a href=http://www.php.net/manual/en/timezones.php>http://www.php.net/manual/en/timezones.php</a>.</p><h2 id=a-iddb-namedb11-variazioni-nel-supporto-ai-databasea>11. Variazioni nel supporto ai database</h2><h3 id=a-iddb1-namedb111a-panoramica-su-pdo-a>11a. Panoramica su PDO</h3><p>PHP Data Objects (PDO) è stato introdotto in PHP 5.0 come una estensione PECL, ed è diventato parte della distribuzione di PHP in PHP 5.1 L&rsquo;estensione PDO offre una interfaccia omogenea per l&rsquo;accesso ai database, ed è usata al fianco di specifici driver PDO. Ogni driver può anche avere specifiche funzioni di gestione dei database, ma le funzionalità di base quali l&rsquo;invio delle queries ed il prelevamento dei risultati sono coperte dalle funzioni di PDO, attraverso l&rsquo;utilizzo del driver richiamati nel PDO::__construct().
Si noti che l&rsquo;estensione PDO, ed i suoi driver, sono da compilare preferibilmente come estensioni condivise. Ciò permetterà semplici aggiornamenti da PECL, senza costringervi a ricompilare tutto il PHP.
Con la versione PHP 5.1, PDO è più che pronto per un test diffuso e può essere adottato in molte situazioni. Comunque, è importante capire che PDO ed i suoi driver sono relativamente giovani e possono essere deficitari di specifiche caratteristiche di un database; valutate PDO con cautela prima di usarlo in nuovi progetti.
Il vecchio codice conterà sulle pre-esistenti estensioni per database, che sono ancora supportate.
Ci sono informazioni più approfondite sull&rsquo;estensione PDO nel manuale su <a href=http://www.php.net/manual/ref.pdo.php>http://www.php.net/manual/ref.pdo.php</a>.</p><h3 id=a-iddb2-namedb211b-cambiamenti-nel-supporto-a-mysqla>11b. Cambiamenti nel supporto a MySQL</h3><p>In PHP 4 era incorporato il supporto a MySQL 3. Con la versione 5.0 di PHP c&rsquo;erano due estensioni di MySQL, chiamate &lsquo;mysql&rsquo; e &lsquo;mysqli&rsquo;, progettate per supportare rispettivamente MySQL &lt; 4.1 e MySQL 4.1 e successivi. Con l&rsquo;introduzione di PDO, che fornisce un&rsquo;interfaccia molto veloce a tutte le API dei database supportati da PHP, il driver PDO_MySQL può supportare tutte le versioni correnti (MySQL 3, 4 e 5) nel codice PHP scritto per PDO, a seconda della versione della libreria MySQL usata durante la compilazione. Le estensioni più vecchie di MySQL rimangono in vigore per ragioni di retro-compatibilità, ma non sono abilitate di default.</p><h3 id=a-iddb3-namedb311c-variazioni-nel-supporto-a-sqlitea>11c. Variazioni nel supporto a SQLite</h3><p>In PHP 5.0 era fornito il supporto a SQLite 2 attraverso l&rsquo;estensione sqlite, che era disponibile anche come estensione PECL in PHP 4.3 e PHP 4.4. Con l&rsquo;introduzione di PDO, l&rsquo;estensione sqlite raddoppia per agire come driver &lsquo;sqlite2&rsquo; per PDO; per questo motivo l&rsquo;estensione sqlite in PHP 5.1 ha una dipendenza verso l&rsquo;estensione PDO.
PHP 5.1 porta con se diverse interfacce alternative a sqlite:
l&rsquo;estensione sqlite fornisce la classica API procedurale e ad oggetti che potete aver usato nelle versioni precedenti di PHP. Inoltre fornisce il driver PDO &lsquo;sqlite2&rsquo;, che vi permette di accedere ai precedenti database SQLite 2 utilizzando le API PDO.
PDO_SQLITE fornisce il driver per la versione 3 di &lsquo;sqlite&rsquo;. La versione 3 di SQLite è notevolmente superiore alla versione 2, ma i formati dei file delle due versioni non sono compatibili.
Se il vostro progetto basato su SQLite è già scritto e funziona con le precedenti versioni di PHP, allora potete continuare ad usare ext/sqlite senza problemi, ma avrete bisogni di abilitare esplicitamente sia PDO che sqlite. I nuovi progetti dovrebbero usare PDO ed il driver &lsquo;sqlite&rsquo; (versione 3), visto che è più veloce rispetto a SQLite 2, ha un migliorato bloccaggio concorrente e supporta sia i prepared statements che i campi binari in maniera nativa.
Dovrete abilitare PDO ad usare l&rsquo;estensione SQLite. Se volete compilare l&rsquo;estensione PDO come un estensione condivisa, anche l&rsquo;estensione SQLite deve essere compilata nello stesso modo. Vale la stessa regola per ogni estensione che fornisce un driver PDO.</p><h2 id=a-idmisc-namemisc12-ulteriori-informazioni-sulla-migrazionea>12. Ulteriori informazioni sulla migrazione</h2><p>Per informazioni generali circa la migrazione da PHP 4 a PHP 5, prego riferirsi alla sezione pertinente nel manuale PHP su <a href=http://www.php.net/manual/migration5.php>http://www.php.net/manual/migration5.php</a>.</p><h2 id=a-idestrict-nameestrict13-controllo-degli-errori-e_stricta>13. Controllo degli errori E_STRICT</h2><p>Se avete un singolo script da controllare, potete raccogliere gli errori E_STRICT utilizzando la linea di comando di PHP:</p><p>php -d error_reporting=4095 -l script_to_check.php</p><p>Per progetti più ampi, lo script qui sotto garantirà lo stesso risultato:</p><pre><code>&lt;pre class=&quot;brush: xml&quot;&gt;
#!/bin/sh

directory=$1

shift

# These extensions are checked
extensions=&quot;php inc&quot;

check_file ()
{
 echo -ne &quot;Doing PHP syntax check on $1 ...&quot;

 # Options:
 ERRORS=`/www/php/bin/php -d display_errors=1 -d html_errors=0 -d error_prepend_string=&quot; &quot; -d error_append_string=&quot; &quot; -d error_reporting=4095 -l $1 | grep -v &quot;No syntax errors detected&quot;`

 if test -z &quot;$ERRORS&quot;; then
   echo -ne &quot;OK.&quot;
 else
   echo -e &quot;Errors found!\n$ERRORS&quot;
 fi

 echo
}

# loop over remaining file args
for FILE in &quot;$@&quot; ; do
 for ext in $extensions; do
    if echo $FILE | grep &quot;\.$ext$&quot; &gt; /dev/null; then
      if test -f $FILE; then
        check_file &quot;$FILE&quot;
      fi
    fi
 done
done
</code></pre></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/database/ rel=tag>database</a></li><li class=tags__item><a class="tags__link btn" href=/tags/mysql/ rel=tag>MySQL</a></li><li class=tags__item><a class="tags__link btn" href=/tags/namespace/ rel=tag>namespace</a></li><li class=tags__item><a class="tags__link btn" href=/tags/oracle/ rel=tag>Oracle</a></li><li class=tags__item><a class="tags__link btn" href=/tags/sicurezza/ rel=tag>sicurezza</a></li><li class=tags__item><a class="tags__link btn" href=/tags/mysqli/ rel=tag>mysqli</a></li><li class=tags__item><a class="tags__link btn" href=/tags/pdo/ rel=tag>PDO</a></li><li class=tags__item><a class="tags__link btn" href=/tags/spl/ rel=tag>SPL</a></li><li class=tags__item><a class="tags__link btn" href=/tags/sqlite/ rel=tag>SQLite</a></li></ul></div></footer></article></main><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/articoli/cronometriamo-i-nostri-script/ rel=prev><span class=pager__subtitle>«&#8201;Precedente</span><p class=pager__title>Cronometriamo i nostri script</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=/articoli/lestensione-mysqli-ii/ rel=next><span class=pager__subtitle>Prossimo&#8201;»</span><p class=pager__title>L'estensione mysqli - II</p></a></div></nav></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2021 Giovanni Tomasicchio.
<span class=footer__copyright-credits>Generato con <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> e il tema <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a>.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>