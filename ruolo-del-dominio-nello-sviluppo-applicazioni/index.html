<!doctype html><html class=no-js lang=it><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Il ruolo del dominio nello sviluppo di applicazioni - Giovanni Tomasicchio</title><script>(function(a,b){a[b]=a[b].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Il ruolo del dominio nello sviluppo di applicazioni"><meta property="og:description" content="A scuola abbiamo imparato che per risolvere un problema è utile creare un modello, ovvero una astrazione semplificata della realtà in esame, che contempli solo gli elementi necessari alla descrizione del problema in questione. Ristretto il cerchio alle poche entità che costituiscono il modello individuato, sarà più facile individuare le logiche che ne governano il funzionamento e quindi risolvere il problema.
Ma è proprio necessario che il modello attorno al quale realizziamo una applicazione debba essere costruito sul dominio del problema?"><meta property="og:type" content="article"><meta property="og:url" content="https://giovannitomasicchio.github.io/ruolo-del-dominio-nello-sviluppo-applicazioni/"><meta property="article:section" content="post"><meta property="article:published_time" content="2017-10-15T08:51:39+00:00"><meta property="article:modified_time" content="2017-10-15T08:51:39+00:00"><meta itemprop=name content="Il ruolo del dominio nello sviluppo di applicazioni"><meta itemprop=description content="A scuola abbiamo imparato che per risolvere un problema è utile creare un modello, ovvero una astrazione semplificata della realtà in esame, che contempli solo gli elementi necessari alla descrizione del problema in questione. Ristretto il cerchio alle poche entità che costituiscono il modello individuato, sarà più facile individuare le logiche che ne governano il funzionamento e quindi risolvere il problema.
Ma è proprio necessario che il modello attorno al quale realizziamo una applicazione debba essere costruito sul dominio del problema?"><meta itemprop=datePublished content="2017-10-15T08:51:39+00:00"><meta itemprop=dateModified content="2017-10-15T08:51:39+00:00"><meta itemprop=wordCount content="907"><meta itemprop=keywords content="Domain-driven design,Manifesto Agile,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Il ruolo del dominio nello sviluppo di applicazioni"><meta name=twitter:description content="A scuola abbiamo imparato che per risolvere un problema è utile creare un modello, ovvero una astrazione semplificata della realtà in esame, che contempli solo gli elementi necessari alla descrizione del problema in questione. Ristretto il cerchio alle poche entità che costituiscono il modello individuato, sarà più facile individuare le logiche che ne governano il funzionamento e quindi risolvere il problema.
Ma è proprio necessario che il modello attorno al quale realizziamo una applicazione debba essere costruito sul dominio del problema?"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,regular,italic,600,600italic,700,700italic,800,800italic|Kaushan+Script:regular"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel="shortcut icon" href=/favicon.ico><script async src="https://www.googletagmanager.com/gtag/js?id=G-525H86QENV"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-525H86QENV',{anonymize_ip:!1})}</script></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Giovanni Tomasicchio" rel=home><div class="logo__item logo__text"><div class=logo__title>Giovanni Tomasicchio</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/articoli/><span class=menu__text>Articoli PHP</span></a></li><li class=menu__item><a class=menu__link href=/corsi/><span class=menu__text>Corsi</span></a></li><li class=menu__item><a class=menu__link href=/contatti/><span class=menu__text>Contatti</span></a></li><li class=menu__item><a class=menu__link href=/ricerca/><span class=menu__text>Ricerca</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Il ruolo del dominio nello sviluppo di applicazioni</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-10-15T08:51:39Z>15 October 2017</time></div></div></header><figure class=post__thumbnail><img src=/image/blog/2017/10/Knowledge-Sharing.jpg alt="Il ruolo del dominio nello sviluppo di applicazioni"></figure><div class="content post__content clearfix"><p>A scuola abbiamo imparato che per risolvere un problema è utile creare un <strong>modello</strong>, ovvero una astrazione semplificata della realtà in esame, che contempli solo gli elementi necessari alla descrizione del problema in questione. Ristretto il cerchio alle poche <strong>entità</strong> che costituiscono il modello individuato, sarà più facile individuare le logiche che ne governano il funzionamento e quindi risolvere il problema.</p><p><strong>Ma è proprio necessario che il modello attorno al quale realizziamo una applicazione debba essere costruito sul dominio del problema?</strong></p><p>Il dubbio mi è venuto osservando che ci sono contesti in cui questo approccio non viene rispettato. Ad esempio in matematica ci sono problemi che vengono risolti trasformando (secondo metodologie inventate da Fourier, Laplace e altri grandi matematici) il dominio reale in un dominio “sintetico” ad esso correlato nel quale è più semplice trovare una soluzione. Senza andare troppo lontano, anche nel mondo della programmazione funzionale la tendenza è quella di astrarre il problema e ridurlo ad una sequenza di operazioni sui dati, così lontane dal dominio del problema.</p><h2 id=domain-driven-design>Domain-driven design</h2><figure><img src=/image/blog/2017/10/eric_evans.jpg><figcaption><h4>Eric Evans</h4></figcaption></figure><p>Così ho iniziato a fare una ricerca, e ovviamente sono partito dal lavoro di <a href=https://twitter.com/ericevans0>Eric Evans</a>, ovvero dal <a href=http://www.mokabyte.it/2008/11/domaindriven-1/>Domain-driven design (DDD)</a>, un approccio allo sviluppo del software che si può riassumere nei seguenti punti:</p><ul><li>prestare massima attenzione agli <strong>aspetti fondamentali del dominio</strong> e delle sue logiche;</li><li>realizzare uno o più <strong>modelli sulla base del dominio del problema</strong>, assieme agli esperti di dominio, finalizzati a risolvere i problemi più complessi;</li><li>scrivere software a partire da questi modelli che devono quindi essere <strong>esplicitamente visibili nel codice</strong>;</li><li>utilizzare uno <strong>linguaggio condiviso tra tutti gli stakeholder</strong>, tecnici e non, (ubiquitous language) valido all’interno di ciascun particolare contesto (bounded context).</li></ul><p>Non credo sia necessario entrare nei dettagli del DDD, è evidente che per Evans tutto il processo di sviluppo del software va costruito strategicamente sul dominio. L’autore descrive il suo modello nel libro <a href=https://www.amazon.it/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215>Domain-Driven Design, Tackling Complexity in the Heart of Software</a>, nella cui prefazione, curata da <a href=https://martinfowler.com/>Martin Fowler</a>, si pone l’accento sul rapporto tra i tecnici e gli esperti di dominio:</p><blockquote><p>The greatest value of a domain model is that it provides ubiquitous language that ties domain experts and technologists together.</p></blockquote><p>Il dominio quindi non solo per comprendere e risolvere il problema ma come punto di incontro tra tecnici ed esperti di dominio, tra sviluppatori e committenti. Il dominio quindi nel DDD assume una valenza più ampia rispetto al ruolo giocato da un semplice modello.</p><h2 id=manifesto-agile>Manifesto Agile</h2><figure><img src=/image/blog/2017/10/martin_fowler.jpg><figcaption><h4>Martin Fowler</h4></figcaption></figure><p>Fowler è uno dei 17 firmatari del <a href=http://agilemanifesto.org/iso/it/manifesto.html>Manifesto Agile</a>, pertanto sono andato a verificare se questi concetti fossero in qualche modo presenti tra i 12 principi del manifesto, ed ho trovato il seguente:</p><blockquote><p>Committenti e sviluppatori devono lavorare insieme quotidianamente per tutta la durata del progetto.</p></blockquote><p>Come possono lavorare insieme quotidianamente gli sviluppatori ed il committente se parlano una lingua diversa? E’ evidente che l’<em>ubiquitous language</em> del DDD è uno strumento adatto ad <strong>accorciare le distanze tra i tecnici ed il committente</strong>, obiettivo evidentemente auspicato anche dal Manifesto Agile.</p><p>Sullo stesso tema, Fowler sottolinea l’importanza della <strong><a href=https://martinfowler.com/bliki/CustomerAffinity.html>Customer Affinity</a></strong>, ovvero “l’interesse e la vicinanza che gli sviluppatori dimostrano nei confronti dei problemi di business che il software risolve e delle persone che lavorano in quel business”.</p><figure><img src=/image/blog/2017/10/kent.jpg><figcaption><h4>Kent Beck</h4></figcaption></figure><p>Fowler afferma che il suo apprezzamento nei confronti dell’<a href=https://it.wikipedia.org/wiki/Extreme_programming>Extreme Programming</a> (XP) e delle altre metodologie agili deriva principalmente dall’importanza che queste attribuiscono alla customer affinity. Egli ricorda che, in occasione degli incontri che portarono alla definizione del Manifesto Agile, <a href=https://it.wikipedia.org/wiki/Kent_Beck>Kent Beck</a>, presentando l’XP, preferì evidenziare non gli aspetti più tecnici della sua metodologia ma il suo desiderio di <strong>modificare la natura dei rapporti tra committenti e sviluppatori</strong>.</p><h2 id=performance-e-adattabilità-al-cambiamento>Performance e adattabilità al cambiamento</h2><p>A questo punto della mia ricerca, il dominio sembra essere il Santo Graal dello sviluppo moderno. Un dubbio ancora mi rimane: scrivendo codice che trasuda dominio da tutte le righe e che pertanto tende ad essere prolisso, <strong>non corriamo il rischio di mortificare le performance?</strong> In fondo il software è costituito da istruzioni rivolte ad una macchina mentre il dominio è un concetto legato al committente e al suo business. Istruire la macchina sul da farsi utilizzando direttamente la logica del dominio può avere delle ripercussioni di natura tecnica?</p><figure><img src=/image/blog/2017/10/carlo_pescio.jpg><figcaption><h4>Carlo Pescio</h4></figcaption></figure><p>La risposta l’ho trovata in un recente lavoro di <a href=http://www.eptacom.net>Carlo Pescio</a>, dal titolo <a href=https://drive.google.com/file/d/0B59Tysg-nEQZSXRqVjJmQjZyVXc/view>Programming as if the Domain (and Performance) Mattered</a>. Nell’articolo viene dimostrato con rigore scientifico come le <strong>migliori performance</strong> non si ottengono mediante lo sfruttamento delle caratteristiche di un linguaggio di programmazione, bensì attraverso una <strong>migliore conoscenza del dominio del problema</strong>.</p><p>La dimostrazione viene condotta considerando due differenti implementazioni, una di tipo funzionale, in Haskell, orientata all’implementazione di un algoritmo, e l’altra in C#, secondo un modello ad oggetti basato sul dominio. Pescio dimostra come, contrariamente a quanto si possa ipotizzare, l’implementazione in C# risulta più performante. Inoltre la soluzione basata sul dominio si dimostra anche molto più <strong>adattabile ai cambiamenti</strong> del problema iniziale rispetto all’approccio algoritmico. Il dominio quindi come uno <strong>strumento <em>agile</em></strong>.</p><h2 id=conclusioni>Conclusioni</h2><p>La centralità del dominio, così come emerge da tutte le fonti che ho consultato in questa mia ricerca, mi porta ad inevitabili riflessioni sugli effetti di pratiche che invece sembrano ignorarne la valenza. Mi riferisco ad esempio ad un sostenuto turnover all’interno del team di sviluppo e ai passaggi di interi progetti da un team uscente verso un nuovo team. Sono evenienze non così rare, motivate spesso da interessi economici, che temo possano avere conseguenze nel lungo periodo tutt’altro che economiche.</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/domain-driven-design/ rel=tag>Domain-driven design</a></li><li class=tags__item><a class="tags__link btn" href=/tags/manifesto-agile/ rel=tag>Manifesto Agile</a></li></ul></div></footer></article></main><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/kiss-me-im-nerd/ rel=prev><span class=pager__subtitle>«&#8201;Precedente</span><p class=pager__title>Kiss me, I’m a nerd</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=/cose-larchitettura-un-software/ rel=next><span class=pager__subtitle>Prossimo&#8201;»</span><p class=pager__title>Cos’è l’architettura di un software?</p></a></div></nav></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2021 Giovanni Tomasicchio.
<span class=footer__copyright-credits>Generato con <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> e il tema <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a>.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>