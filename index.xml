<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Giovanni Tomasicchio</title><link>https://giovanni.tomasicchio.gitlab.io/website/</link><description>Recent content on Giovanni Tomasicchio</description><generator>Hugo -- gohugo.io</generator><language>it-IT</language><lastBuildDate>Tue, 02 Jan 2018 15:50:26 +0000</lastBuildDate><atom:link href="https://giovanni.tomasicchio.gitlab.io/website/index.xml" rel="self" type="application/rss+xml"/><item><title>CAP, ACID, BASE e Eventual Consistency</title><link>https://giovanni.tomasicchio.gitlab.io/website/cap-acid-base-eventual-consistency/</link><pubDate>Tue, 02 Jan 2018 15:50:26 +0000</pubDate><guid>https://giovanni.tomasicchio.gitlab.io/website/cap-acid-base-eventual-consistency/</guid><description>Per chi è abituato a lavorare con sistemi centralizzati, costituiti ad esempio da una applicazione monolitica dotata di un unico database relazionale, la realizzazione di un sistema distribuito si presenta ricca di insidie. Ne facevo cenno già in un precedente post in cui cercavo di far luce sui problemi che l’astrazione offerta dai moderni strumenti riesce a nascondere ma non a risolvere del tutto. Uno di questi problemi è legato al concetto di consistenza dei dati sparsi in un sistema distribuito.</description></item><item><title>Eventi di dominio in Spring framework</title><link>https://giovanni.tomasicchio.gitlab.io/website/eventi-dominio-spring-framework/</link><pubDate>Sat, 16 Dec 2017 16:22:54 +0000</pubDate><guid>https://giovanni.tomasicchio.gitlab.io/website/eventi-dominio-spring-framework/</guid><description>Qualche giorno fa un collega mi ha chiesto consigli su come disaccoppiare il codice che gestisce la logica di business dal codice che produce eventuali “reazioni” del sistema all’operazione eseguita. La sua necessità sorgeva dal fatto che l’applicazione su cui sta lavorando, realizzata con Spring framework, sarebbe stata utilizzata da diversi clienti, ciascuno dei quali avrebbe potenzialmente richiesto, per la medesima operazione principale, l’esecuzione di differenti operazioni secondarie. Una soluzione a questo problema è l’introduzione nel sistema degli eventi di dominio.</description></item><item><title>High-Performance Java Persistence – recensione</title><link>https://giovanni.tomasicchio.gitlab.io/website/high-performance-java-persistence-recensione/</link><pubDate>Sat, 18 Nov 2017 11:19:45 +0000</pubDate><guid>https://giovanni.tomasicchio.gitlab.io/website/high-performance-java-persistence-recensione/</guid><description>Ho appena finito di leggere, anzi, di divorare, il libro “High-Performance Java Persistence” di Vlad Mihalcea. Molte recensioni positive mi hanno spinto ad acquistarlo, nella versione cartacea attraverso Amazon, ma non mi aspettavo un testo al contempo così pragmatico, accessibile, dettagliato, scientifico ed in certi punti anche illuminante.
L’autore, che tra l’altro è uno degli sviluppatori di Hibernate, in questo testo analizza i molteplici fattori che influenzano le performance del layer di persistenza dei dati in una applicazione Java.</description></item><item><title>Sull’organizzazione dei team di sviluppo</title><link>https://giovanni.tomasicchio.gitlab.io/website/organizzazione-dei-team-sviluppo/</link><pubDate>Sun, 29 Oct 2017 22:10:39 +0000</pubDate><guid>https://giovanni.tomasicchio.gitlab.io/website/organizzazione-dei-team-sviluppo/</guid><description>L’argomento in questione è di grande attualità in ufficio ed è per questo che mi sento in dovere di condividere in questo post la mia visione sull’organizzazione ideale dei team di sviluppo, frutto di un decennio di osservazioni delle dinamiche lavorative.
Il mio ragionamento parte dalla costatazione che la suddivisione dell’intero organico in diversi gruppi è necessaria ed inevitabile, e non per ragioni organizzative ma antropologiche. I gruppi sociali si formano spontaneamente, pertanto è meglio crearli secondo logiche di produttività.</description></item><item><title>Cos’è l’architettura di un software?</title><link>https://giovanni.tomasicchio.gitlab.io/website/cose-larchitettura-un-software/</link><pubDate>Sun, 22 Oct 2017 17:12:13 +0000</pubDate><guid>https://giovanni.tomasicchio.gitlab.io/website/cose-larchitettura-un-software/</guid><description>Prima di continuare a leggere questo post, provate a dare una risposta. Secondo vuoi cos’è l’architettura di un software?
Non si tratta di un discorso meramente teorico, finalizzato a trovare una definizione sterile. Al contrario, abbiamo bisogno di trovare una risposta perché da questa dipende la nostra capacità di valutare la bontà di una architettura. In altre parole abbiamo bisogno di sapere cos’è l’architettura di un software per avere un criterio che ci guidi nell’effettuare corrette scelte architetturali.</description></item><item><title>Il ruolo del dominio nello sviluppo di applicazioni</title><link>https://giovanni.tomasicchio.gitlab.io/website/ruolo-del-dominio-nello-sviluppo-applicazioni/</link><pubDate>Sun, 15 Oct 2017 08:51:39 +0000</pubDate><guid>https://giovanni.tomasicchio.gitlab.io/website/ruolo-del-dominio-nello-sviluppo-applicazioni/</guid><description>A scuola abbiamo imparato che per risolvere un problema è utile creare un modello, ovvero una astrazione semplificata della realtà in esame, che contempli solo gli elementi necessari alla descrizione del problema in questione. Ristretto il cerchio alle poche entità che costituiscono il modello individuato, sarà più facile individuare le logiche che ne governano il funzionamento e quindi risolvere il problema.
Ma è proprio necessario che il modello attorno al quale realizziamo una applicazione debba essere costruito sul dominio del problema?</description></item><item><title>Kiss me, I’m a nerd</title><link>https://giovanni.tomasicchio.gitlab.io/website/kiss-me-im-nerd/</link><pubDate>Thu, 12 Oct 2017 16:57:29 +0000</pubDate><guid>https://giovanni.tomasicchio.gitlab.io/website/kiss-me-im-nerd/</guid><description>Fatemelo dire a chiare lettere: nell’industria IT non c’è più spazio per gli sviluppatori nerd. Mi riferisco a coloro che sono attratti dalle soluzioni complesse, dagli hack, dalle over-ingegnerizzazioni e da tutto ciò che, per essere compreso, richieda un QI elevato e, al contempo, mostrano seri problemi nelle relazioni interpersonali.
KISS La letteratura dell’ingegneria del software parla chiaro, basta citare il principio KISS (Keep It Simple, Stupid) con cui si esorta a mantenere il codice sorgente semplice, lineare e comprensibile.</description></item><item><title>REST, quanto costa l’infedeltà?</title><link>https://giovanni.tomasicchio.gitlab.io/website/rest-quanto-costa-infedelta/</link><pubDate>Sun, 01 Oct 2017 21:39:22 +0000</pubDate><guid>https://giovanni.tomasicchio.gitlab.io/website/rest-quanto-costa-infedelta/</guid><description>In questo ultimo post sul modello REST voglio provare a rispondere ad una semplice domanda: perché dovremmo rimanere fedeli al modello REST quando realizziamo applicazioni web?
Per farlo dobbiamo partire dagli obiettivi che questa architettura si pone:
scalabilità geografica; adozione di interfacce generiche (es.: HTTP, URI, ecc.) condivise tra tutti i client e server; deploy indipendente dei componenti (es.: siti web, web app, browser, motori di ricerca, ecc.); adozione di middleware per ridurre la latenza delle interazioni (es.</description></item><item><title>REST, applicazione al Web ed ai servizi RESTful</title><link>https://giovanni.tomasicchio.gitlab.io/website/rest-applicazione-al-web-ed-ai-servizi-restful/</link><pubDate>Sat, 23 Sep 2017 14:44:32 +0000</pubDate><guid>https://giovanni.tomasicchio.gitlab.io/website/rest-applicazione-al-web-ed-ai-servizi-restful/</guid><description>Nel precedente post vi ho raccontato delle vicende che hanno portato alla definizione del modello REST. Non è il caso di entrare nel merito della descrizione, piuttosto formale, che ne fa l’autore nella sua tesi di dottorato. Vediamo invece quali sono i concetti chiave di questa architettura e come questi siano riscontrabili nel Web e più di recente abbiano ispirato i servizi RESTful*.
Risorse e identificativi Nel modello REST si parla di risorse e dei relativi identificativi, che corrispondono nel Web ai documenti (html, jpg, css, ecc.</description></item><item><title>Architettura REST, le origini</title><link>https://giovanni.tomasicchio.gitlab.io/website/architettura-rest-le-origini/</link><pubDate>Mon, 18 Sep 2017 06:45:49 +0000</pubDate><guid>https://giovanni.tomasicchio.gitlab.io/website/architettura-rest-le-origini/</guid><description>Chiacchierando tra colleghi mi sono accorto che chi viene dal mondo SOAP e si avvicina ai servizi RESTful commette spesso l’errore di pensare che la principale differenza tra i due approcci sia solo la notazione utilizzata per lo scambio dei dati, XML per i servizi SOAP e JSON per quelli RESTful. Per avere un’idea più corretta sui concetti alla base di questi servizi è necessario fare un salto nel passato e seguire la nascita del Web per come lo conosciamo adesso.</description></item><item><title>Ereditarietà, solo per (sviluppatori) adulti</title><link>https://giovanni.tomasicchio.gitlab.io/website/ereditarieta-solo-sviluppatori-adulti/</link><pubDate>Fri, 15 Sep 2017 20:24:56 +0000</pubDate><guid>https://giovanni.tomasicchio.gitlab.io/website/ereditarieta-solo-sviluppatori-adulti/</guid><description>Visto l’interesse suscitato dal precedente post sulla relazione di ereditarietà, torno sull’argomento per mettere in risalto ulteriori vincoli da essa imposti.
Lo so, a volte anche le costrizioni possono risultare piacevoli… ed è proprio quello che accade con l’ereditarietà tra classi, certamente vincolante ma così immediata nel realizzare il riuso del codice. E allora, per allontanare questi pensieri impuri dai nostri progetti, recitiamo insieme la seguente preghiera tratta da uno dei testi sacri della programmazione ad oggetti:</description></item><item><title>Ereditarietà, usarla con cautela</title><link>https://giovanni.tomasicchio.gitlab.io/website/ereditarieta-usarla-con-cautela/</link><pubDate>Fri, 08 Sep 2017 18:07:24 +0000</pubDate><guid>https://giovanni.tomasicchio.gitlab.io/website/ereditarieta-usarla-con-cautela/</guid><description>In questo post voglio condividere alcune osservazioni sulle caratteristiche della relazione di ereditarietà nella programmazione object-oriented. Provo a farlo con un esempio.
Dobbiamo individuare il modello delle classi per una applicazione che gestisca l’archivio dei film di una videoteca. Per ciascun film dobbiamo memorizzare il regista e gli attori. Viene immediato individuare almeno tre classi: Film, Regista e Attore, collegate nel seguente modo:
Poiché dobbiamo realizzare delle funzionalità che operano sia sugli attori che sui registi, come ad esempio il motore di ricerca degli artisti, abbiamo bisogno del polimorfismo e quindi introduciamo una classe Artista.</description></item><item><title>Cloud computing, ci interessa davvero?</title><link>https://giovanni.tomasicchio.gitlab.io/website/cloud-computing-ci-interessa-davvero/</link><pubDate>Wed, 30 Aug 2017 17:51:44 +0000</pubDate><guid>https://giovanni.tomasicchio.gitlab.io/website/cloud-computing-ci-interessa-davvero/</guid><description>Non sono un venditore di servizi cloud e quindi non starò qui a fare uno spot su queste tecnologie. Il web è ricco di dissertazioni sul cloud, sono certo che vi sarete già fatti una idea sui pro e contro. Il punto è un altro. Come progettisti di applicazioni, dovremmo in qualche modo farci ispirare dal cloud nella realizzazione del nostro prossimo progetto?
Non mi riferisco tanto alle soluzioni di tipo “Infrastructure as a Service” (IAAS), incentrate sull’offerta di server virtuali, connettività di rete, server per lo storage e backup.</description></item><item><title>Sorgente e runtime, le insidie dell’astrazione</title><link>https://giovanni.tomasicchio.gitlab.io/website/sorgente-e-runtime-le-insidie-dellastrazione/</link><pubDate>Thu, 24 Aug 2017 13:35:17 +0000</pubDate><guid>https://giovanni.tomasicchio.gitlab.io/website/sorgente-e-runtime-le-insidie-dellastrazione/</guid><description>Quando sviluppiamo tendiamo a trascurare gli aspetti legati al momento dell’esecuzione del codice, al così detto runtime. Questo capita maggiormente quando si ha a che fare con i linguaggi di alto livello, magari a macchina virtuale come il Java che “gira” all’interno di una JVM o il C# eseguito da una CLR, ma anche con i linguaggi di scripting come il PHP interpretato ed eseguito dallo Zend Engine. Questi ambienti di runtime infatti operano dietro le quinte, ad esempio gestendo in maniera trasparente l’allocazione dinamica della memoria.</description></item><item><title>Hello world!</title><link>https://giovanni.tomasicchio.gitlab.io/website/hello-world/</link><pubDate>Sun, 20 Aug 2017 22:21:05 +0000</pubDate><guid>https://giovanni.tomasicchio.gitlab.io/website/hello-world/</guid><description>Stavo per modificare il titolo del primo post che WordPress crea durante la sua installazione quando mi sono accorto che “Hello world!” è proprio adatto ad avviare il blog di uno sviluppatore software. Si, perché su questo diario vorrei condividere alcune personali riflessioni sulla programmazione e, più in generale, su tutto ciò che ruota attorno alla realizzazione del software.
L’attività lavorativa e lo studio dei guru della programmazione mi portano spesso a fare delle considerazioni che generalmente si limitano a ronzarmi per la testa e che solo raramente riesco a condividere con amici e colleghi davanti ad un caffè.</description></item></channel></rss>