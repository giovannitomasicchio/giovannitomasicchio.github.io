<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>REST, quanto costa l’infedeltà? - Giovanni Tomasicchio</title><script>(function(a,b){a[b]=a[b].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="REST, quanto costa l’infedeltà?"><meta property="og:description" content="In questo ultimo post sul modello REST voglio provare a rispondere ad una semplice domanda: perché dovremmo rimanere fedeli al modello REST quando realizziamo applicazioni web?
Per farlo dobbiamo partire dagli obiettivi che questa architettura si pone:
 scalabilità geografica; adozione di interfacce generiche (es.: HTTP, URI, ecc.) condivise tra tutti i client e server; deploy indipendente dei componenti (es.: siti web, web app, browser, motori di ricerca, ecc.); adozione di middleware per ridurre la latenza delle interazioni (es."><meta property="og:type" content="article"><meta property="og:url" content="https://giovannitomasicchio.github.io/rest-quanto-costa-infedelta/"><meta property="article:section" content="post"><meta property="article:published_time" content="2017-10-01T21:39:22+00:00"><meta property="article:modified_time" content="2017-10-01T21:39:22+00:00"><meta itemprop=name content="REST, quanto costa l’infedeltà?"><meta itemprop=description content="In questo ultimo post sul modello REST voglio provare a rispondere ad una semplice domanda: perché dovremmo rimanere fedeli al modello REST quando realizziamo applicazioni web?
Per farlo dobbiamo partire dagli obiettivi che questa architettura si pone:
 scalabilità geografica; adozione di interfacce generiche (es.: HTTP, URI, ecc.) condivise tra tutti i client e server; deploy indipendente dei componenti (es.: siti web, web app, browser, motori di ricerca, ecc.); adozione di middleware per ridurre la latenza delle interazioni (es."><meta itemprop=datePublished content="2017-10-01T21:39:22+00:00"><meta itemprop=dateModified content="2017-10-01T21:39:22+00:00"><meta itemprop=wordCount content="1420"><meta itemprop=keywords content="HTTP,REST,RESTful,URI,"><meta name=twitter:card content="summary"><meta name=twitter:title content="REST, quanto costa l’infedeltà?"><meta name=twitter:description content="In questo ultimo post sul modello REST voglio provare a rispondere ad una semplice domanda: perché dovremmo rimanere fedeli al modello REST quando realizziamo applicazioni web?
Per farlo dobbiamo partire dagli obiettivi che questa architettura si pone:
 scalabilità geografica; adozione di interfacce generiche (es.: HTTP, URI, ecc.) condivise tra tutti i client e server; deploy indipendente dei componenti (es.: siti web, web app, browser, motori di ricerca, ecc.); adozione di middleware per ridurre la latenza delle interazioni (es."><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,regular,italic,600,600italic,700,700italic,800,800italic|Kaushan+Script:regular"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel="shortcut icon" href=/favicon.ico><script async src="https://www.googletagmanager.com/gtag/js?id=G-525H86QENV"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-525H86QENV',{anonymize_ip:!1})}</script></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Giovanni Tomasicchio" rel=home><div class="logo__item logo__text"><div class=logo__title>Giovanni Tomasicchio</div></div></a></div><div class=divider></div></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>REST, quanto costa l’infedeltà?</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-10-01T21:39:22Z>1 October 2017</time></div></div></header><figure class=post__thumbnail><img src=/wp-content/uploads/2017/10/infedelta.jpg alt="REST, quanto costa l’infedeltà?"></figure><div class="content post__content clearfix"><p>In questo ultimo post sul modello REST voglio provare a rispondere ad una semplice domanda: <strong>perché dovremmo rimanere fedeli al <a href=/rest-applicazione-al-web-ed-ai-servizi-restful/>modello REST</a> quando realizziamo applicazioni web</strong>?</p><p>Per farlo dobbiamo partire dagli obiettivi che questa architettura si pone:</p><ol><li>scalabilità geografica;</li><li>adozione di interfacce generiche (es.: HTTP, URI, ecc.) condivise tra tutti i client e server;</li><li>deploy indipendente dei componenti (es.: siti web, web app, browser, motori di ricerca, ecc.);</li><li>adozione di middleware per ridurre la latenza delle interazioni (es.: proxy web con funzionalità di cache).</li></ol><p>Avrete certamente riconosciuto temi importanti che si incrociano quotidianamente nello sviluppo di applicazioni web, d’altronde il Web non è altro che l’implementazione del modello REST su scala mondiale. Eppure nello sviluppo web non sempre si adottano soluzioni in linea con questa architettura.</p><p>Realizzare applicazioni web senza rispettare il modello REST non è necessariamente un errore ma generalmente porta a risultati che non beneficiano delle caratteristiche precedentemente elencate. Provo quindi a fare qualche esempio di mancato rispetto del modello REST nelle applicazioni web, per analizzarne di volta in volta le conseguenze. Per individuare questi casi basta cercare i contesti in cui vengono utilizzati, ma non rispettati, gli standard HTTP e URI* che sono alla base dell’adozione del modello REST nel Web.</p><h2 id=single-page-application>Single-page application</h2><p>Le <a href=http://itsnat.sourceforge.net/php/spim/spi_manifesto_en.php>single-page application</a> sono quelle applicazioni web che espongono tutte le loro funzionalità su di un singolo URI. Queste applicazioni non rispettano il principio REST secondo cui ad un identificativo deve essere associata una specifica risorsa, pertanto <strong>non rispettano una dell’interfacce generiche del Web, gli URI</strong>. Ne consegue che <strong>i client di queste applicazioni</strong>, come i browser, i motori di ricerca e i sistemi di analisi del traffico, <strong>non funzioneranno correttamente</strong>. Infatti:</p><ul><li>La cronologia del browser rimane ferma all’unico URL utilizzato dall’applicazione e di conseguenza le frecce “avanti” e “indietro” del browser non funzionano come dovrebbero. Per la stessa ragione anche i “preferiti” del browser sono piuttosto inefficaci. È necessario adottare specifiche strategie (<a href=https://en.wikipedia.org/wiki/Fragment_identifier title="Fragment identifier">Fragment identifier</a> o <a href=https://developer.mozilla.org/en-US/docs/Web/API/History_API title="Comparison of layout engines (HTML5)">History API</a>) per aggirare il problema.</li><li>I motori di ricerca non riescono a navigare all’interno dell’applicazione e ad indicizzare le diverse risorse poiché queste vengono servite dallo stesso URL.</li><li>I servizi di analisi del traffico web hanno difficoltà a distinguere le visite effettuate alle diverse sezioni dell’applicazione.</li></ul><h2 id=submit-ripetuto-dei-form>Submit ripetuto dei form</h2><p>Vi è mai capitato di utilizzare la freccia “indietro” del browser ed imbattervi in quell’avviso che vi chiede conferma sull’invio del form? Ciò succede quando <strong>l’applicazione web non rispetta il significato dei verbi, o metodi, dell’HTTP</strong>.</p><p>Secondo le specifiche di questo protocollo, il metodo GET deve essere utilizzato esclusivamente per recuperare una risorsa dal server, quindi soltanto nei link delle pagine HTML e nei form di ricerca. Il metodo POST invece deve essere utilizzato per richiedere al server di accettare l’entità (i dati) presenti nella request come subordinati rispetto a quelli associati all’URL. In risposta il server dovrebbe limitarsi ad indicare l’esito della richiesta, ad esempio 201 Created, ed un URL su cui proseguire la navigazione mediante una nuova richiesta GET.</p><p>Spesso invece le applicazioni web rispondono ad una richiesta POST con una pagina HTML. Il browser la aggiunge alla sua history, associandola alla request necessaria al suo ottenimento. Queste request dovrebbero essere tutte di tipo GET, quindi ripetibili senza ripercussioni per il server, ma l’applicazione web non sta rispettando il protocollo. Alla pressione del tasto “indietro”, <strong>il browser ci chiede conferma prima di ripetere il POST, poiché questo tipo di richiesta potrebbe modificare lo stato del server</strong>. Il mancato rispetto del protocollo HTTP può esporre quindi la nostra applicazione ad indesiderate ed involontarie modifiche ai dati, semplicemente navigando la history del browser.</p><p>L’approccio più corretto che una web app dovrebbe seguire va sotto il nome di <a href=https://en.wikipedia.org/wiki/Post/Redirect/Get>pattern PRG</a> (Post, Redirect, Get) secondo cui il server, a fronte di una richiesta di tipo POST, deve rispondere con un redirect all’URL contenente la successiva risorsa da restituire al browser. Questa verrà recuperata con una ulteriore request, questa volta di tipo GET.</p><h2 id=post-nei-form-di-ricerca>POST nei form di ricerca</h2><p>I form HTML impiegati per la ricerca all’interno di archivi dovrebbero sempre utilizzare il metodo GET. Infatti questi form servono a recuperare risorse dal server (GET), non a modificare lo stato del server (POST). A volte invece questi form utilizzano erroneamente delle request di tipo POST a cui il server risponde direttamente con la pagina web contenente i risultati. Oltre ai problemi di submit ripetuto precedentemente descritti, <strong>questo errore impedisce ai sistemi di cache</strong> (browser, proxy cache) <strong>di funzionare</strong> poiché lo standard prevede che la response di un POST non venga memorizzata in cache. Inoltre <strong>le pagine dei risultati non saranno indicizzabili</strong> dai motori di ricerca poiché, come le single page application, su di un unico URL vengono mostrati risultati di ricerche aventi diversi criteri.</p><h2 id=servizi-soap>Servizi SOAP</h2><p>I servizi SOAP su HTTP sono un caso eclatante di <strong>utilizzo “abusivo” degli URI e dell’HTTP</strong>, anzi sono in contrapposizione con il modello REST. Infatti su di un unico URL vengono esposte diverse risorse e funzionalità. Inoltre l’HTTP viene utilizzato solamente come “lascia passare” verso i vari apparati di sicurezza delle reti, generalmente configurati per consentire le trasmissioni effettuate con questo protocollo. I messaggi XML dei servizi SOAP contengono tutte le informazioni necessarie all’interazione client-server. Non serve quindi utilizzare l’URI come sistema di identificazione delle risorse, né l’HTTP per specificare cosa chiede il client e l’esito di tale richiesta.</p><p>Banalizzando potremmo dire che l’interfaccia di un qualsiasi sito o applicazione web è identica: URI e HTTP. Ed infatti un qualunque client, come un browser, è in grado di interagire correttamente con qualsiasi sito o applicazione web. Invece l’interfaccia dei servizi SOAP è sempre diversa e non è possibile realizzare un client che funzioni con tutti i servizi SOAP. Lo sviluppo di un client SOAP non può prescindere dalla conoscenza dell’interfaccia del particolare servizio SOAP con cui dovrà interagire. Anzi, molto spesso si realizza un servizio SOAP conoscendo già il sistema che dovrà invocarlo.</p><p>Ne consegue che i tradizionali sistemi di navigazione ed indicizzazione del Web non funzionano coi i servizi SOAP che invece ricorrono a specifiche soluzioni, come i <a href=https://it.wikipedia.org/wiki/Web_Services_Description_Language>WSDL</a> e i registri <a href=https://it.wikipedia.org/wiki/Universal_Description_Discovery_and_Integration>UDDI</a>. Inoltre in SOAP l’utilizzo di interfacce specifiche impedisce anche l’impiego di tradizionali sistemi intermediari, come proxy web con funzione di cache o di controllo degli accessi, poiché questi non saprebbero come interpretare i messaggi SOAP. Anche in questo caso ci si affida a specifiche soluzioni come, ad esempio, gli <a href=https://it.wikipedia.org/wiki/Enterprise_Service_Bus>ESB</a>.</p><p>I servizi RESTful su HTTP si affidano invece a questo protocollo e agli URI per adottare una interfaccia standard tra client e server. Di conseguenza si prestano meglio all’utilizzo “world wide”, sotto forma di <a href=https://it.wikipedia.org/wiki/Application_programming_interface>API</a> a disposizione di un generico sistema client, non noto al server. Se ben realizzato, per navigare all’interno delle risorse esposte da un servizio RESTful è sufficiente conoscere l’URL principale dal quale si dovrebbero ricevere informazioni sulle altre risorse (URL) disponibili, un po’ come accade con la home page di un sito web che permette di accedere, mediante link, a tutte le ulteriori pagine del sito.</p><p>I servizi RESTful quindi non sono né migliori né peggiori dei servizi SOAP. I primi fanno uso di interfacce standard orientate alle risorse, i secondi invece utilizzano interfacce specifiche, orientate per lo più all’esecuzione di procedure remote (<a href=https://it.wikipedia.org/wiki/Chiamata_di_procedura_remota>RPC</a>), di derivazione <a href=https://it.wikipedia.org/wiki/Remote_Method_Invocation>RMI</a> e <a href=https://it.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture>CORBA</a>.</p><h2 id=conclusioni>Conclusioni</h2><p>Dopo questa lunga dissertazione provo a condensare il tutto con tre concetti che, a mio avviso, dovrebbero essere ben chiari a ciascuno sviluppatore web.</p><ol><li>Sviluppare applicazioni web significa costruire software utilizzando degli standard (URI, HTTP, HTML, ecc.) che pertanto devono essere sufficientemente conosciuti.</li><li>Questi standard costituiscono le interfacce generiche utilizzate da tutti i componenti della rete (server, browser, motori di ricerca, proxy, ecc.). Se questi standard non vengono rispettati dal nostro applicativo, qualche componente smetterà di funzionare correttamente.</li><li>Gli standard del Web si ispirano al modello REST per raggiungere gli obiettivi che questa architettura si pone. Rispettare questi standard consente alle nostre applicazioni di raggiungere gli stessi obiettivi senza dover introdurre specifiche soluzioni.</li></ol><p>_<strong>_</strong></p><ul><li>A ben vedere neanche gli standard URI e HTTP rispettano perfettamente il modello REST. Infatti in un URL è possibile inserire lo username e la password del client per accedere a risorse protette da meccanismi di sicurezza. Ma gli identificativi delle risorse REST devono contenere solo informazioni relative al server, non al client. Anche i cookie dell’HTTP non rispettano il modello REST, infatti contengono dati associati non ad un singolo URL ma a tutti gli URL di un determinato percorso. Questi dati poi non sono semanticamente strutturati e pertanto risultano potenzialmente pericolosi. Con essi infatti è possibile tracciare la navigazione di un utente.</li></ul></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/http/ rel=tag>HTTP</a></li><li class=tags__item><a class="tags__link btn" href=/tags/rest/ rel=tag>REST</a></li><li class=tags__item><a class="tags__link btn" href=/tags/restful/ rel=tag>RESTful</a></li><li class=tags__item><a class="tags__link btn" href=/tags/uri/ rel=tag>URI</a></li></ul></div></footer></article></main><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/rest-applicazione-al-web-ed-ai-servizi-restful/ rel=prev><span class=pager__subtitle>«&#8201;Previous</span><p class=pager__title>REST, applicazione al Web ed ai servizi RESTful</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=/kiss-me-im-nerd/ rel=next><span class=pager__subtitle>Next&#8201;»</span><p class=pager__title>Kiss me, I’m a nerd</p></a></div></nav></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2021 Giovanni Tomasicchio.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>