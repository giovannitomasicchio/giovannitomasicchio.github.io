<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Domain-driven design on Giovanni Tomasicchio</title><link>https://giovannitomasicchio.github.io/tags/domain-driven-design/</link><description>Recent content in Domain-driven design on Giovanni Tomasicchio</description><generator>Hugo -- gohugo.io</generator><language>it-IT</language><lastBuildDate>Tue, 02 Jan 2018 15:50:26 +0000</lastBuildDate><atom:link href="https://giovannitomasicchio.github.io/tags/domain-driven-design/index.xml" rel="self" type="application/rss+xml"/><item><title>CAP, ACID, BASE e Eventual Consistency</title><link>https://giovannitomasicchio.github.io/cap-acid-base-eventual-consistency/</link><pubDate>Tue, 02 Jan 2018 15:50:26 +0000</pubDate><guid>https://giovannitomasicchio.github.io/cap-acid-base-eventual-consistency/</guid><description>Per chi è abituato a lavorare con sistemi centralizzati, costituiti ad esempio da una applicazione monolitica dotata di un unico database relazionale, la realizzazione di un sistema distribuito si presenta ricca di insidie. Ne facevo cenno già in un precedente post in cui cercavo di far luce sui problemi che l’astrazione offerta dai moderni strumenti riesce a nascondere ma non a risolvere del tutto. Uno di questi problemi è legato al concetto di consistenza dei dati sparsi in un sistema distribuito.</description></item><item><title>Eventi di dominio in Spring framework</title><link>https://giovannitomasicchio.github.io/eventi-dominio-spring-framework/</link><pubDate>Sat, 16 Dec 2017 16:22:54 +0000</pubDate><guid>https://giovannitomasicchio.github.io/eventi-dominio-spring-framework/</guid><description>Qualche giorno fa un collega mi ha chiesto consigli su come disaccoppiare il codice che gestisce la logica di business dal codice che produce eventuali “reazioni” del sistema all’operazione eseguita. La sua necessità sorgeva dal fatto che l’applicazione su cui sta lavorando, realizzata con Spring framework, sarebbe stata utilizzata da diversi clienti, ciascuno dei quali avrebbe potenzialmente richiesto, per la medesima operazione principale, l’esecuzione di differenti operazioni secondarie. Una soluzione a questo problema è l’introduzione nel sistema degli eventi di dominio.</description></item><item><title>Sull’organizzazione dei team di sviluppo</title><link>https://giovannitomasicchio.github.io/organizzazione-dei-team-sviluppo/</link><pubDate>Sun, 29 Oct 2017 22:10:39 +0000</pubDate><guid>https://giovannitomasicchio.github.io/organizzazione-dei-team-sviluppo/</guid><description>L’argomento in questione è di grande attualità in ufficio ed è per questo che mi sento in dovere di condividere in questo post la mia visione sull’organizzazione ideale dei team di sviluppo, frutto di un decennio di osservazioni delle dinamiche lavorative.
Il mio ragionamento parte dalla costatazione che la suddivisione dell’intero organico in diversi gruppi è necessaria ed inevitabile, e non per ragioni organizzative ma antropologiche. I gruppi sociali si formano spontaneamente, pertanto è meglio crearli secondo logiche di produttività.</description></item><item><title>Il ruolo del dominio nello sviluppo di applicazioni</title><link>https://giovannitomasicchio.github.io/ruolo-del-dominio-nello-sviluppo-applicazioni/</link><pubDate>Sun, 15 Oct 2017 08:51:39 +0000</pubDate><guid>https://giovannitomasicchio.github.io/ruolo-del-dominio-nello-sviluppo-applicazioni/</guid><description>A scuola abbiamo imparato che per risolvere un problema è utile creare un modello, ovvero una astrazione semplificata della realtà in esame, che contempli solo gli elementi necessari alla descrizione del problema in questione. Ristretto il cerchio alle poche entità che costituiscono il modello individuato, sarà più facile individuare le logiche che ne governano il funzionamento e quindi risolvere il problema.
Ma è proprio necessario che il modello attorno al quale realizziamo una applicazione debba essere costruito sul dominio del problema?</description></item></channel></rss>