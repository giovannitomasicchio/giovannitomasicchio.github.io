<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ETL on Giovanni Tomasicchio</title><link>https://giovanni.tomasicchio.gitlab.io/website/tags/etl/</link><description>Recent content in ETL on Giovanni Tomasicchio</description><generator>Hugo -- gohugo.io</generator><language>it-IT</language><lastBuildDate>Thu, 24 Aug 2017 13:35:17 +0000</lastBuildDate><atom:link href="https://giovanni.tomasicchio.gitlab.io/website/tags/etl/index.xml" rel="self" type="application/rss+xml"/><item><title>Sorgente e runtime, le insidie dell’astrazione</title><link>https://giovanni.tomasicchio.gitlab.io/website/sorgente-e-runtime-le-insidie-dellastrazione/</link><pubDate>Thu, 24 Aug 2017 13:35:17 +0000</pubDate><guid>https://giovanni.tomasicchio.gitlab.io/website/sorgente-e-runtime-le-insidie-dellastrazione/</guid><description>Quando sviluppiamo tendiamo a trascurare gli aspetti legati al momento dell’esecuzione del codice, al così detto runtime. Questo capita maggiormente quando si ha a che fare con i linguaggi di alto livello, magari a macchina virtuale come il Java che “gira” all’interno di una JVM o il C# eseguito da una CLR, ma anche con i linguaggi di scripting come il PHP interpretato ed eseguito dallo Zend Engine. Questi ambienti di runtime infatti operano dietro le quinte, ad esempio gestendo in maniera trasparente l’allocazione dinamica della memoria.</description></item></channel></rss>