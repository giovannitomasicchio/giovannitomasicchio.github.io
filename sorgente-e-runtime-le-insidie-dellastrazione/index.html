<!doctype html><html class=no-js lang=it><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Sorgente e runtime, le insidie dell’astrazione - Giovanni Tomasicchio</title><script>(function(a,b){a[b]=a[b].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Sorgente e runtime, le insidie dell’astrazione"><meta property="og:description" content="Quando sviluppiamo tendiamo a trascurare gli aspetti legati al momento dell’esecuzione del codice, al così detto runtime. Questo capita maggiormente quando si ha a che fare con i linguaggi di alto livello, magari a macchina virtuale come il Java che “gira” all’interno di una JVM o il C# eseguito da una CLR, ma anche con i linguaggi di scripting come il PHP interpretato ed eseguito dallo Zend Engine. Questi ambienti di runtime infatti operano dietro le quinte, ad esempio gestendo in maniera trasparente l’allocazione dinamica della memoria."><meta property="og:type" content="article"><meta property="og:url" content="https://giovannitomasicchio.github.io/sorgente-e-runtime-le-insidie-dellastrazione/"><meta property="article:section" content="post"><meta property="article:published_time" content="2017-08-24T13:35:17+00:00"><meta property="article:modified_time" content="2017-08-24T13:35:17+00:00"><meta itemprop=name content="Sorgente e runtime, le insidie dell’astrazione"><meta itemprop=description content="Quando sviluppiamo tendiamo a trascurare gli aspetti legati al momento dell’esecuzione del codice, al così detto runtime. Questo capita maggiormente quando si ha a che fare con i linguaggi di alto livello, magari a macchina virtuale come il Java che “gira” all’interno di una JVM o il C# eseguito da una CLR, ma anche con i linguaggi di scripting come il PHP interpretato ed eseguito dallo Zend Engine. Questi ambienti di runtime infatti operano dietro le quinte, ad esempio gestendo in maniera trasparente l’allocazione dinamica della memoria."><meta itemprop=datePublished content="2017-08-24T13:35:17+00:00"><meta itemprop=dateModified content="2017-08-24T13:35:17+00:00"><meta itemprop=wordCount content="834"><meta itemprop=keywords content="astrazione,ETL,eventual consistency,Integrazione,RESTful,scalabilità,teorema CAP,test di carico,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Sorgente e runtime, le insidie dell’astrazione"><meta name=twitter:description content="Quando sviluppiamo tendiamo a trascurare gli aspetti legati al momento dell’esecuzione del codice, al così detto runtime. Questo capita maggiormente quando si ha a che fare con i linguaggi di alto livello, magari a macchina virtuale come il Java che “gira” all’interno di una JVM o il C# eseguito da una CLR, ma anche con i linguaggi di scripting come il PHP interpretato ed eseguito dallo Zend Engine. Questi ambienti di runtime infatti operano dietro le quinte, ad esempio gestendo in maniera trasparente l’allocazione dinamica della memoria."><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,regular,italic,600,600italic,700,700italic,800,800italic|Kaushan+Script:regular"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel="shortcut icon" href=/favicon.ico><script async src="https://www.googletagmanager.com/gtag/js?id=G-525H86QENV"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-525H86QENV',{anonymize_ip:!1})}</script></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Giovanni Tomasicchio" rel=home><div class="logo__item logo__text"><div class=logo__title>Giovanni Tomasicchio</div><div class=logo__tagline>not just code monkeys</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Home</span></a></li><li class=menu__item><a class=menu__link href=/articoli/><span class=menu__text>Articoli PHP</span></a></li><li class=menu__item><a class=menu__link href=/corsi/><span class=menu__text>Corsi</span></a></li><li class=menu__item><a class=menu__link href=/contatti/><span class=menu__text>Contatti</span></a></li><li class=menu__item><a class=menu__link href=/ricerca/><span class=menu__text>Ricerca</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Sorgente e runtime, le insidie dell’astrazione</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-08-24T13:35:17Z>24 August 2017</time></div></div></header><figure class=post__thumbnail><img src=/image/blog/2017/08/astrazione-1.jpg alt="Sorgente e runtime, le insidie dell’astrazione"></figure><div class="content post__content clearfix"><p>Quando sviluppiamo tendiamo a <strong>trascurare gli aspetti legati al momento dell’esecuzione del codice</strong>, al così detto runtime. Questo capita maggiormente quando si ha a che fare con i linguaggi di alto livello, magari a macchina virtuale come il Java che “gira” all’interno di una <a href=https://it.wikipedia.org/wiki/Macchina_virtuale_Java>JVM</a> o il C# eseguito da una <a href=https://it.wikipedia.org/wiki/Common_Language_Runtime>CLR</a>, ma anche con i linguaggi di scripting come il PHP interpretato ed eseguito dallo <a href=http://www.zend.com/en/products/zend_server#engine>Zend Engine</a>. Questi ambienti di runtime infatti operano dietro le quinte, ad esempio gestendo in maniera trasparente l’allocazione dinamica della memoria.</p><p>Ad allontanare ulteriormente il codice che scriviamo nei sorgenti da ciò che viene realmente eseguito a runtime ci sono altri ingombranti layer software come il <strong>framework</strong> impiegato, l’<strong>application server</strong> e lo stesso **sistema operativo, **virtualizzazioni e container Docker compresi. I più insidiosi a mio avviso sono i framework web, sia quelli lato server (<a href=https://spring.io/>Spring</a>, <a href=https://www.asp.net/mvc>ASP.NET MVC</a>, <a href=https://framework.zend.com/>Zend</a>, <a href=https://symfony.com/>Symfony</a>), sia quelli lato client (<a href=https://angular.io/>Angular</a>, <a href=https://facebook.github.io/react/>React</a>), che per semplificare il compito dello sviluppatore nascondono la reale natura del web (fatto principalmente di HTTP, HTML e javascript)</p><p>In generale non penso che questo <strong>livello di astrazione</strong> sia un problema, anzi, è la soluzione alla sempre crescente complessità dei sistemi che siamo chiamati a realizzare. Oggi possiamo contare su hardware in grado di digerire anche le applicazioni più pesanti e su reti sempre più veloci. Godiamoci quindi l’ebrezza, <strong>scrivendo solo poche righe di codice</strong>, di estrarre da database, elaborare e trasferire tonnellate di dati tra due applicazioni web su rete geografica via servizi RESTful, magari in JSON o XML, il tutto in frazioni di secondo.</p><p>Ma non è tutto oro quel che luccica! Ci sono alcuni aspetti, legati al runtime, che l’astrazione del codice sorgente non ci deve far perdere di vista. Cito solo qualche esempio, se ne avete altri potete magari riportarli nei commenti (grazie!).</p><h2 id=scalabilità>Scalabilità</h2><p><em>…quando le risorse iniziano a scarseggiare.</em></p><p>Partendo dal presupposto che le micro-ottimizzazioni del codice hanno senso solo in rare circostanze, dobbiamo comunque prestare attenzione al consumo delle risorse (CPU, RAM, storage, banda, database, I/O sul filesystem, ecc.) in certi contesti, in particolare quelli che richiedono <strong>scalabilità</strong>.</p><p>Se ad esempio realizziamo una funzionalità web che alloca nella sessione utente un misero megabyte di RAM, se utilizzata da mille utenti tale consumo lievita ad un giga. In Java o C# non è così immediato capire, a partire dal sorgete, quanta memoria dinamica verrà allocata dall’ambiente di runtime. Ancora più difficile capire se, e quando, verrà liberata questa memoria. Possono venirci in soccorso i <strong>test di carico</strong> (JMeter), ovvero quei test che simulano l’utilizzo del nostro software da parte di un certo numero di utenti. Monitorando il comportamento del server in termini di risorse utilizzate potremo verificare se la nostra applicazione scala bene in funzione del numero di utenti.</p><p>Un’altra particolare tipologia di applicativi che merita attenzione è quella dei processi di <strong><a href=https://it.wikipedia.org/wiki/Extract,_transform,_load>ETL</a></strong>, ovvero quella in cui si leggono, elaborano e scrivono grosse quantità di dati. Dal punto di vista del sorgente non c’è differenza tra le seguenti implementazioni:</p><ol><li>leggere tutto, elaborare tutto, scrivere tutto;</li><li>leggere una porzione di dati, elaborare quanto letto, scrivere quanto elaborato, ripetere dall’inizio fino allo smaltimento di tutti i dati.</li></ol><p>E’ evidente che la prima implementazione è la più immediata da realizzare ma non scala bene con il crescere del volume dei dati da trattare.</p><h2 id=integrazione>Integrazione</h2><p><em>…le distanze contano.</em></p><p>Se stiamo usando un moderno framework web, dal punto di vista del codice sorgente, non c’è differenza tra chiamare un comune metodo di una qualunque classe ed invocare un servizio RESTful o SOAP. Scambiare informazioni tra una applicazione Android e un servizio RESTful esposto su un server remoto è questione di semplici chiamate a metodo, se visto con gli occhi del programmatore.</p><p>Ma sappiamo bene che in realtà, a runtime, la cosa è molto più complessa. Il framework infatti, in maniera del tutto trasparente e automatica, si occupa di effettuare il marshalling/unmarshalling dei dati e la trasmissione di questi via rete. E poi ci sono le incognite sulla disponibilità e raggiungibilità del sistema da invocare. Quindi, oltre a dover considerare il diverso “peso” di una chiamata a sistema remoto, dobbiamo:</p><ol><li>gestire i problemi di lentezza o indisponibilità dei sistemi remoti in ciascuna invocazione effettuata;</li><li>progettare l’intera applicazione affinché sia minimizzato l’impatto dell’indisponibilità dei sistemi remoti;</li><li>fare attenzione alle transazioni che coinvolgono sistemi remoti, per via dei vincoli esposti nel <a href=https://it.wikipedia.org/wiki/Teorema_CAP>teorema CAP</a> e affidarsi a soluzioni di tipo <a href=https://en.wikipedia.org/wiki/Eventual_consistency>Eventual consistency</a>.</li></ol><p>Su questo ultimo punto cercherò di tornare in un <a href=https://www.giovannitomasicchio.it/cap-acid-base-eventual-consistency/>prossimo post</a>.</p><h2 id=conclusioni>Conclusioni</h2><p>Quelli che ho citato sono solo alcuni degli scenari in cui l’astrazione dei linguaggi di alto livello e dei framework di sviluppo può far sottovalutare la reale complessità sottostante e portare a prendere delle decisioni sbagliate in fase di progettazione e sviluppo di una funzionalità. Il mio consiglio è quindi quello di non perdere mai di vista il “runtime” poiché, in fin dei conti, il software non è altro che l’insieme delle istruzioni che l’hardware dovrà eseguire. Dobbiamo quindi progettare l’architettura dei sorgenti ma anche l’architettura del runtime, considerando la reciproca influenza.</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/astrazione/ rel=tag>astrazione</a></li><li class=tags__item><a class="tags__link btn" href=/tags/etl/ rel=tag>ETL</a></li><li class=tags__item><a class="tags__link btn" href=/tags/eventual-consistency/ rel=tag>eventual consistency</a></li><li class=tags__item><a class="tags__link btn" href=/tags/integrazione/ rel=tag>Integrazione</a></li><li class=tags__item><a class="tags__link btn" href=/tags/restful/ rel=tag>RESTful</a></li><li class=tags__item><a class="tags__link btn" href=/tags/scalabilit%C3%A0/ rel=tag>scalabilità</a></li><li class=tags__item><a class="tags__link btn" href=/tags/teorema-cap/ rel=tag>teorema CAP</a></li><li class=tags__item><a class="tags__link btn" href=/tags/test-di-carico/ rel=tag>test di carico</a></li></ul></div></footer></article></main><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/hello-world/ rel=prev><span class=pager__subtitle>«&#8201;Precedente</span><p class=pager__title>Hello world!</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=/cloud-computing-ci-interessa-davvero/ rel=next><span class=pager__subtitle>Prossimo&#8201;»</span><p class=pager__title>Cloud computing, ci interessa davvero?</p></a></div></nav><section class=comments><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//giovannitomasicchio-it.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2021 Giovanni Tomasicchio.
<span class=footer__copyright-credits>Generato con <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> e il tema <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a>.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>